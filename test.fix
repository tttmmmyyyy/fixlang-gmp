module Test;

import GMP.Z;
import GMP.Q;

test : IO ();
test = (
    test_z;;
    test_q;;
    pure()
);

test_z : IO ();
test_z = (
    test_z_memory;;
    test_z_conversion;;
    test_z_basic_arithmetic;;
    test_z_comparison;;
    test_z_pow;;
    test_z_root;;
    test_z_bit;;

    // zero and one
    assert_eq(|_|"zero", MPZ::zero.to_string, "0");;
    assert_eq(|_|"one", MPZ::one.to_string, "1");;

    // constructor
    assert_eq(|_|"mpz", mpz(42).to_string, "42");;

    pure()
);


test_z_memory : IO ();
test_z_memory = (
    // Test of `_mutate` via `set_str` in case of unique or shared.
    // unique
    let n = MPZ::init_set_si(2);
    let n = n.set_str("7F", 16).as_some;
    assert_eq(|_|"case set_str 1", n.to_string, "127");;
    // shared
    let n = MPZ::init_set_si(2);
    let m = n.set_str("7F", 16).as_some;
    assert_eq(|_|"case set_str 2", m.to_string, "127");;
    assert_eq(|_|"case set_str 3", n.to_string, "2");;

    // Test of `_unary_op` via `abs` in case of unique or shared.
    // unique
    let n = MPZ::init_set_si(-1234);
    let m = n.abs;
    assert_eq(|_|"case 2", m.to_string, "1234");;
    // shared
    let n = MPZ::init_set_si(-1234);
    let m = n.abs;
    assert_eq(|_|"case 2", m.to_string, "1234");;
    assert_eq(|_|"case 2", n.to_string, "-1234");;

    // Test of `_binary_op` via `tdiv_q` in case of (n, d) is (unique, unique), (unique, shared), (shared, unique), (shared, shared).
    // (unique, unique)
    let n = MPZ::init_set_si(7);
    let d = MPZ::init_set_si(3);
    let q = n.tdiv_q(d);
    assert_eq(|_|"case 2", q.to_string, "2");;
    // (unique, shared)
    let n = MPZ::init_set_si(7);
    let d = MPZ::init_set_si(3);
    let q = n.tdiv_q(d);
    assert_eq(|_|"case 2", q.to_string, "2");;
    assert_eq(|_|"case 2", n.to_string, "7");;    
    // (unique, shared)
    let n = MPZ::init_set_si(7);
    let d = MPZ::init_set_si(3);
    let q = n.tdiv_q(d);
    assert_eq(|_|"case 2", q.to_string, "2");;
    assert_eq(|_|"case 2", d.to_string, "3");;    
    // (shared, shared)
    let n = MPZ::init_set_si(7);
    let d = MPZ::init_set_si(3);
    let q = n.tdiv_q(d);
    assert_eq(|_|"case 2", q.to_string, "2");;
    assert_eq(|_|"case 2", n.to_string, "7");;    
    assert_eq(|_|"case 2", d.to_string, "3");;

    // Test of `_binary_op` via `tdiv_q` in case of (n, n) is given where n is unique or shared.
    // unique
    let n = MPZ::init_set_si(7);
    let q = n.tdiv_q(n);
    assert_eq(|_|"case 3", q.to_string, "1");;
    // shared
    let n = MPZ::init_set_si(7);
    let q = n.tdiv_q(n);
    assert_eq(|_|"case 3", q.to_string, "1");;
    assert_eq(|_|"case 3", n.to_string, "7");;

    // Test of `_binary_op` via `tdiv_qr` in case of (n, d) is (unique, unique), (unique, shared), (shared, unique), (shared, shared).
    // (unique, unique)
    let n = MPZ::init_set_si(7);
    let d = MPZ::init_set_si(3);
    let (q, r) = n.tdiv_qr(d);
    assert_eq(|_|"case 2", q.to_string, "2");;
    assert_eq(|_|"case 2", r.to_string, "1");;
    // (unique, shared)
    let n = MPZ::init_set_si(7);
    let d = MPZ::init_set_si(3);
    let (q, r) = n.tdiv_qr(d);
    assert_eq(|_|"case 2", q.to_string, "2");;
    assert_eq(|_|"case 2", r.to_string, "1");;
    assert_eq(|_|"case 2", n.to_string, "7");;    
    // (unique, shared)
    let n = MPZ::init_set_si(7);
    let d = MPZ::init_set_si(3);
    let (q, r) = n.tdiv_qr(d);
    assert_eq(|_|"case 2", q.to_string, "2");;
    assert_eq(|_|"case 2", r.to_string, "1");;
    assert_eq(|_|"case 2", d.to_string, "3");;    
    // (shared, shared)
    let n = MPZ::init_set_si(7);
    let d = MPZ::init_set_si(3);
    let (q, r) = n.tdiv_qr(d);
    assert_eq(|_|"case 2", q.to_string, "2");;
    assert_eq(|_|"case 2", r.to_string, "1");;
    assert_eq(|_|"case 2", n.to_string, "7");;    
    assert_eq(|_|"case 2", d.to_string, "3");;

    // Test of `_binary_op2` via `tdiv_qr` in case of (n, n) is given whre n is unique or shared.
    // unique
    let n = MPZ::init_set_si(7);
    let (q, r) = n.tdiv_qr(n);
    assert_eq(|_|"case 3", q.to_string, "1");;
    assert_eq(|_|"case 3", r.to_string, "0");;
    // shared
    let n = MPZ::init_set_si(7);
    let (q, r) = n.tdiv_qr(n);
    assert_eq(|_|"case 3", q.to_string, "1");;
    assert_eq(|_|"case 3", r.to_string, "0");;
    assert_eq(|_|"case 3", n.to_string, "7");;

    pure()
);

test_z_basic_arithmetic : IO ();
test_z_basic_arithmetic = (
    // Addition
    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678);
    let z = x + y;
    assert_eq(|_|"case 4", z.to_string, "6912");;

    // Subtraction (both unique)
    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678);
    let z = x - y;
    assert_eq(|_|"case 5", z.to_string, "-4444");;

    // Subtraction (lhs shared)
    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678);
    let z = x - y;
    assert_eq(|_|"case 5.1", z.to_string, "-4444");;
    let z = z - x;
    assert_eq(|_|"case 5.1.0", z.to_string, "-5678");;

    // Subtraction (rhs shared)
    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678);
    let z = x - y;
    assert_eq(|_|"case 5.2", z.to_string, "-4444");;
    let z = z + y;
    assert_eq(|_|"case 5.2.0", z.to_string, "1234");;

    // Subtraction (both shared)
    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678);
    let z = x - y;
    assert_eq(|_|"case 5.3", z.to_string, "-4444");;
    let z = z - x + y;
    assert_eq(|_|"case 5.3.0", z.to_string, "0");;

    // Multiplication
    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678);
    let z = x * y;
    assert_eq(|_|"case 6", z.to_string, "7006652");;

    // Negation
    let x = MPZ::init_set_si(1234);
    let y = -x;
    assert_eq(|_|"case 7", y.to_string, "-1234");;

    // Negation (shared)
    let x = MPZ::init_set_si(1234);
    let y = -x;
    let z = y + x;
    assert_eq(|_|"case 7.1", z.to_string, "0");;

    // Division
    let q = MPZ::init_set_si(5) / MPZ::init_set_si(2);
    let r = MPZ::init_set_si(5) % MPZ::init_set_si(2);
    assert_eq(|_|"case 15", q.to_string, "2");;
    assert_eq(|_|"case 15", r.to_string, "1");;

    let q = MPZ::init_set_si(5) / MPZ::init_set_si(-2);
    let r = MPZ::init_set_si(5) % MPZ::init_set_si(-2);
    assert_eq(|_|"case 15.5", q.to_string, "-2");;
    assert_eq(|_|"case 15.5", r.to_string, "1");;

    let q = MPZ::init_set_si(-5) / MPZ::init_set_si(2);
    let r = MPZ::init_set_si(-5) % MPZ::init_set_si(2);
    assert_eq(|_|"case 16", q.to_string, "-2");;
    assert_eq(|_|"case 16", r.to_string, "-1");;

    let q = MPZ::init_set_si(-5) / MPZ::init_set_si(-2);
    let r = MPZ::init_set_si(-5) % MPZ::init_set_si(-2);
    assert_eq(|_|"case 16", q.to_string, "2");;
    assert_eq(|_|"case 16", r.to_string, "-1");;

    // truncated division
    let (q, r) = MPZ::init_set_si(-5).tdiv_qr(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", q.to_string, "-1");;
    assert_eq(|_|"case 18", r.to_string, "-2");;
    let q = MPZ::init_set_si(-5).tdiv_q(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", q.to_string, "-1");;
    let r = MPZ::init_set_si(-5).tdiv_r(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", r.to_string, "-2");;
    let q = MPZ::init_set_si(13).tdiv_q_2exp(2_U64);
    assert_eq(|_|"case 18", q.to_string, "3");;
    let r = MPZ::init_set_si(13).tdiv_r_2exp(2_U64);
    assert_eq(|_|"case 18", r.to_string, "1");;

    // ceiling division
    let (q, r) = MPZ::init_set_si(-5).cdiv_qr(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", q.to_string, "-1");;
    assert_eq(|_|"case 18", r.to_string, "-2");;
    let q = MPZ::init_set_si(-5).cdiv_q(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", q.to_string, "-1");;
    let r = MPZ::init_set_si(-5).cdiv_r(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", r.to_string, "-2");;
    let q = MPZ::init_set_si(13).cdiv_q_2exp(2_U64);
    assert_eq(|_|"case 18", q.to_string, "4");;
    let r = MPZ::init_set_si(13).cdiv_r_2exp(2_U64);
    assert_eq(|_|"case 18", r.to_string, "-3");;    

    // floor division
    let (q, r) = MPZ::init_set_si(-5).fdiv_qr(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", q.to_string, "-2");;
    assert_eq(|_|"case 18", r.to_string, "1");;
    let q = MPZ::init_set_si(-5).fdiv_q(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", q.to_string, "-2");;
    let r = MPZ::init_set_si(-5).fdiv_r(MPZ::init_set_si(3));
    assert_eq(|_|"case 18", r.to_string, "1");;
    let q = MPZ::init_set_si(13).fdiv_q_2exp(2_U64);
    assert_eq(|_|"case 18", q.to_string, "3");;
    let r = MPZ::init_set_si(13).fdiv_r_2exp(2_U64);
    assert_eq(|_|"case 18", r.to_string, "1");;        

    // Exact division
    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678 * 1234);
    let z = MPZ::init_set_si(5678);
    assert(|_|"", y.divisible_p(x));;
    assert(|_|"", y.divexact(x) == z);;
    assert(|_|"", !z.divisible_p(x));;
    let x = MPZ::init_set_si(16);
    assert(|_|"", x.divisible_2exp_p(4_U64));;
    assert(|_|"", !x.divisible_2exp_p(5_U64));;

    // Modulo
    let n = MPZ::init_set_si(5);
    let d = MPZ::init_set_si(2);
    let r = n.mod(d);
    assert_eq(|_|"case 0", r.to_string, "1");;

    // Congruence
    assert(|_|"mpz congruent_p 1", mpz(1).congruent_p(mpz(2), mpz(3)));;
    assert(|_|"mpz congruent_2exp_p", mpz(8).congruent_2exp_p(3_U64, mpz(0)));;

    // addmul
    assert_eq(|_|"mpz addmul", mpz(1).addmul(mpz(2), mpz(3)), mpz(7));;

    // submul
    assert_eq(|_|"mpz submul", mpz(1).submul(mpz(2), mpz(3)), mpz(-5));;

    // mul_2exp
    let x = MPZ::init_set_si(1234);
    let y = x.mul_2exp(10_U64);
    assert_eq(|_|"case 9", y.to_string, "1263616");;

    // Absolute value
    let x = MPZ::init_set_si(-1234);
    let y = x.abs;
    assert_eq(|_|"case 8", y.to_string, "1234");;

    pure()
);

test_z_conversion : IO ();
test_z_conversion = (
    let num = MPZ::zero;
    assert_eq(|_|"case 0", num.to_string, "0");;

    let num = MPZ::init_set_si(-12345);
    assert_eq(|_|"case 2", num.to_string, "-12345");;

    let num = num.set_si(54321);
    assert_eq(|_|"case 2.1", num.to_string, "54321");;

    let num = MPZ::from_U64(31415_U64);
    assert_eq(|_|"case 3", num.to_string, "31415");;

    let num = num.set_U64(27182_U64);
    assert_eq(|_|"case 3.1", num.to_string, "27182");;

    let num = num.set_F64(3.14159);
    assert_eq(|_|"case 4", num.to_string, "3");;

    let num = MPZ::from_F64(3.14159);
    assert_eq(|_|"case 4", num.to_string, "3");;

    // Test `to_I64`
    let num = MPZ::init_set_si(1234);
    assert_eq(|_|"case to_I64 success", num.to_I64.as_some, 1234);;

    let num = (from_string("12345678901234567890123").as_ok : MPZ);
    assert(|_|"case to_I64 fail", num.to_I64.is_none);;

    // Test `to_U64`
    let num = MPZ::from_U64(1234_U64);
    assert_eq(|_|"case to_U64 success", num.to_U64.as_some, 1234_U64);;

    let num = (from_string("12345678901234567890123").as_ok : MPZ);
    assert(|_|"case to_U64 fail", num.to_U64.is_none);;

    // Test `to_F64`
    let num = MPZ::init_set_si(1234);
    assert_eq(|_|"case to_F64", num.MPZ::to_F64, 1234.0);;

    // Test `to_F64_2exp`
    let num = from_string("5").as_ok : MPZ;
    let (mantissa, exponent) = num.to_F64_2exp;
    assert_eq(|_|"case to_F64_2exp mantissa", mantissa, 0.625);;
    assert_eq(|_|"case to_F64_2exp exponent", exponent, 3);;

    // Test `set_MPQ`
    let q = MPQ::init_set_si(6, 5);
    let n = MPZ::init_set_si(0);
    let m = n.set_MPQ(q);
    assert_eq(|_|"case 0", m.to_string, "1");;
    assert_eq(|_|"case 0", n.to_string, "0");;

    let n = MPZ::init_set_si(255);
    assert_eq(|_|"case 1", n.get_string(16), "ff");;

    pure()
);

test_z_comparison : IO ();
test_z_comparison = (
    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678);
    assert(|_|"case 7", x != y);;

    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(1234);
    assert(|_|"case 7", x == y);;

    let x = MPZ::init_set_si(1234);
    assert(|_|"case 7", x == x);;

    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(5678);
    assert(|_|"case 8", x < y);;
    assert(|_|"case 8", !(x > y));;
    assert(|_|"case 8", x <= y);;
    assert(|_|"case 8", !(x >= y));;

    let x = MPZ::init_set_si(1234);
    let y = MPZ::init_set_si(1234);
    assert(|_|"case 8", !(x < y));;
    assert(|_|"case 8", !(x > y));;
    assert(|_|"case 8", x <= y);;
    assert(|_|"case 8", x >= y);;

    let x = MPZ::init_set_si(1234);
    assert(|_|"case 8", !(x < x));;
    assert(|_|"case 8", !(x > x));;
    assert(|_|"case 8", x <= x);;
    assert(|_|"case 8", x >= x);;

    assert(|_|"case 9", cmp(zero, one) < 0);;
    assert(|_|"case 9", cmp(zero, zero) == 0);;
    assert(|_|"case 9", cmp(one, zero) > 0);;

    assert(|_|"case 10", cmp_d(zero, -0.5) > 0);; 
    assert(|_|"case 10", cmp_d(zero, 0.5) < 0);; 

    assert(|_|"case 11", cmpabs(mpz(-2), mpz(-1)) > 0);;
    assert(|_|"case 11", cmpabs(mpz(-2), mpz(2)) == 0);;
    assert(|_|"case 11", cmpabs(mpz(1), mpz(-2)) < 0);;

    assert(|_|"case 12", cmpabs_d(mpz(-2), -1.5) > 0);;
    assert(|_|"case 12", cmpabs_d(mpz(1), -2.5) < 0);;

    assert_eq(|_|"case 13", mpz(-2).sgn, -1);;
    assert_eq(|_|"case 13", mpz(0).sgn, 0);;
    assert_eq(|_|"case 13", mpz(2).sgn, 1);;

    pure()
);

test_z_pow : IO ();
test_z_pow = (
    let z = mpz(2).powm(mpz(10), mpz(1000));
    assert_eq(|_|"case 0", z.to_string, "24");;

    let z = mpz(2).powm_sec(mpz(10), mpz(1000));
    assert_eq(|_|"case 1", z.to_string, "24");;

    let z = mpz(2).pow_ui(10_U64);
    assert_eq(|_|"case 2", z.to_string, "1024");;

    pure()
);

test_z_root : IO ();
test_z_root = (
    let z = mpz(27).root(3_U64);
    assert_eq(|_|"case 0", z, mpz(3));;

    let (root, rem) = mpz(27).root_rem(2_U64);
    assert_eq(|_|"case 1", root, mpz(5));;
    assert_eq(|_|"case 1", rem, mpz(2));;

    let z = mpz(27).sqrt;
    assert_eq(|_|"case 2", z, mpz(5));;

    let (root, rem) = mpz(27).sqrt_rem;
    assert_eq(|_|"case 3", root, mpz(5));;
    assert_eq(|_|"case 3", rem, mpz(2));;

    assert(|_|"case 4", mpz(27).perfect_power_p);;
    assert(|_|"case 4", !mpz(27).perfect_square_p);;

    pure()
);

test_z_bit : IO ();
test_z_bit = (
    let x = init_set_str("101010", 2).as_some;
    let y = init_set_str("110011", 2).as_some;
    let z = x.and(y);
    assert_eq(|_|"case 0", z.get_string(2), "100010");;
    let z = x.or(y);
    assert_eq(|_|"case 1", z.get_string(2), "111011");;
    let z = x.xor(y);
    assert_eq(|_|"case 2", z.get_string(2), "11001");; // leading zero removed
    let z = x.com;
    assert_eq(|_|"case 3", z, -x-mpz(1));;
    
    assert_eq(|_|"case 4", x.scan0(0_U64), 0_U64);;
    assert_eq(|_|"case 4", x.scan1(0_U64), 1_U64);;

    // popcount
    assert_eq(|_|"case 5", x.popcount, 3_U64);;

    // hamdist
    assert_eq(|_|"case 6", x.hamdist(y), 3_U64);;

    // setbit
    assert_eq(|_|"case 7", x.setbit(2_U64).get_string(2), "101110");;

    // clrbit
    assert_eq(|_|"case 8", x.clrbit(1_U64).get_string(2), "101000");;

    // combit
    assert_eq(|_|"case 9", x.combit(1_U64).get_string(2), "101000");;

    // tstbit
    assert(|_|"case 10", x.tstbit(1_U64));;

    pure()
);

test_q : IO ();
test_q = (
    let x = MPQ::zero;
    let n = x.get_num;
    let d = x.get_den;
    assert_eq(|_|"case 0", n.to_string, "0");;
    assert_eq(|_|"case 0", d.to_string, "1");;

    let x = MPQ::one;
    let n = x.get_num;
    let d = x.get_den;
    assert_eq(|_|"case 0.5", n.to_string, "1");;
    assert_eq(|_|"case 0.5", d.to_string, "1");;

    // mpq
    // assert_eq(|_|"mpq", mpq(42, 14).to_string, "3");;
    
    // todo: to_string

    let x = MPQ::from_MPZ(MPZ::init_set_si(1234));
    let y = MPQ::from_MPZ(MPZ::init_set_si(5678));
    let z = y / x;
    let n = z.get_num;
    let d = z.get_den;
    assert_eq(|_|"case 1", n.to_string, "2839");;
    assert_eq(|_|"case 1", d.to_string, "617");;

    let x = MPQ::from_MPZ(MPZ::init_set_si(1234));
    let y = MPQ::from_MPZ(MPZ::init_set_si(5678));
    let z = y / x;
    let f = z.MPQ::to_F64;
    assert_eq(|_|"case 2", f.to_string_precision(9_U8), "4.601296596");;

    let xn = MPQ::from_MPZ(MPZ::init_set_si(12));
    let xd = MPQ::from_MPZ(MPZ::init_set_si(34));
    let yn = MPQ::from_MPZ(MPZ::init_set_si(56));
    let yd = MPQ::from_MPZ(MPZ::init_set_si(78));
    let x = xn / xd;
    let y = yn / yd;

    let z = x + y;
    assert_eq(|_|"case 3", z.get_num.to_string, "710");;
    assert_eq(|_|"case 3", z.get_den.to_string, "663");;

    let z = x - y;
    assert_eq(|_|"case 4", z.get_num.to_string, "-242");;
    assert_eq(|_|"case 4", z.get_den.to_string, "663");;

    let z = x * y;
    assert_eq(|_|"case 5", z.get_num.to_string, "56");;
    assert_eq(|_|"case 5", z.get_den.to_string, "221");;

    let z = x / y;
    assert_eq(|_|"case 6", z.get_num.to_string, "117");;
    assert_eq(|_|"case 6", z.get_den.to_string, "238");;

    let z = -x;
    assert_eq(|_|"case 7", z.get_num.to_string, "-6");;
    assert_eq(|_|"case 7", z.get_den.to_string, "17");;

    assert_eq(|_|"case 8", (x + -x), MPQ::zero);;

    let x = MPQ::init_set_si(1234, 5678);
    assert_eq(|_|"case 9", x.get_num.to_string, "617");;
    assert_eq(|_|"case 9", x.get_den.to_string, "2839");;

    let x = MPQ::init_set_si(-1234, 5678);
    assert_eq(|_|"case 10", x.get_num.to_string, "-617");;
    assert_eq(|_|"case 10", x.get_den.to_string, "2839");;

    let x = MPQ::init_set_si(1234, -5678);
    assert_eq(|_|"case 11", x.get_num.to_string, "-617");;
    assert_eq(|_|"case 11", x.get_den.to_string, "2839");;

    let x = MPQ::init_set_si(-1234, -5678);
    assert_eq(|_|"case 12", x.get_num.to_string, "617");;
    assert_eq(|_|"case 12", x.get_den.to_string, "2839");;

    let x = MPQ::from_U64(1234_U64, 5678_U64);
    assert_eq(|_|"case 13", x.get_num.to_string, "617");;
    assert_eq(|_|"case 13", x.get_den.to_string, "2839");;

    pure()
);