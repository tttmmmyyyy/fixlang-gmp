module GMPZ;

type MPZ = unbox struct { _data : Destructor Ptr };

namespace MPZ {

    // Private or internal functions 
    _make : () -> MPZ;
    _make = |_| (
        let ptr = CALL_C[Ptr fix_mpz_init()];
        let dtor = |ptr| (
            CALL_C[() fix_mpz_clear(Ptr), ptr]
        );
        MPZ { _data : Destructor::make(ptr, dtor) }
    );

    _is_unique_data : MPZ -> (Bool, MPZ);
    _is_unique_data = |num| (
        let (is_unique, data) = num.@_data.is_unique;
        (is_unique, MPZ { _data : data })
    );

    borrow_ptr : (Ptr -> a) -> MPZ -> a;
    borrow_ptr = |proc, num| (
        let res = proc(num.@_data.@value);
        let _ = num; // use num
        res
    );

    force_unique : MPZ -> MPZ;
    force_unique = |src| (
        let (is_unique, src) = src._is_unique_data;
        if is_unique { src };
        let dst = MPZ::_make();
        let _ = dst.borrow_ptr(|dst_ptr| (
            src.borrow_ptr(|src_ptr| (
                CALL_C[() fix_mpz_set(Ptr, Ptr), dst_ptr, src_ptr]
            ))
        ));
        dst
    );

    // Return the argument itself if it is unique, or return zero otherwise.
    make_zero_if_non_unique : MPZ -> MPZ;
    make_zero_if_non_unique = |src| (
        let (is_unique, src) = src._is_unique_data;
        if is_unique { src };
        MPZ::_make()
    );

    // Initializations

    zero : MPZ;
    zero = MPZ::_make();

    // Assining strings

    set_decimal : String -> MPZ -> Option MPZ;
    set_decimal = |dec, num| (
        let num = num.make_zero_if_non_unique;
        num.borrow_ptr(|ptr| (
            let suc = dec.call_with_c_str(|c_str| (
                CALL_C[I64 fix_mpz_set_str(Ptr, Ptr, I64), ptr, c_str, 10]
            ));
            if suc == -1 { Option::none() };
            Option::some $ num
        ))
    );

    from_decimal : String -> Option MPZ;
    from_decimal = |dec| MPZ::zero.set_decimal(dec);

    // Assining integers

    set_I64 : I64 -> MPZ -> MPZ;
    set_I64 = |val, num| (
        let num = num.make_zero_if_non_unique;
        let _ = num.borrow_ptr(|ptr| CALL_C[() fix_mpz_set_si(Ptr, I64), ptr, val]);
        num
    );

    from_I64 : I64 -> MPZ;
    from_I64 = |val| MPZ::zero.set_I64(val);

    set_U64 : U64 -> MPZ -> MPZ;
    set_U64 = |val, num| (
        let num = num.make_zero_if_non_unique;
        let _ = num.borrow_ptr(|ptr| CALL_C[() fix_mpz_set_ui(Ptr, U64), ptr, val]);
        num
    );

    from_U64 : U64 -> MPZ;
    from_U64 = |val| MPZ::zero.set_U64(val);

}

impl MPZ : ToString {

    to_string = |num| (
        num.borrow_ptr(|num_ptr| (
            let len_base = CALL_C[I64 fix_mpz_sizeinbase(Ptr, I64), num_ptr, 10];
            let len = len_base + 2;
            let buf = Array::fill(len, 0_U8);
            let _ = buf.call_with_ptr(|ptr| (
                CALL_C[Ptr fix_mpz_get_str(Ptr, I64, Ptr), ptr, 10, num_ptr]
            ));
            String::from_c_str(buf)
        ))
    );

}