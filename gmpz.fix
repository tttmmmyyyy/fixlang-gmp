module GMP.Z;

import Hash;
import GMP.Q;

// A pointer to struct `__mpz_struct`.
type MPZHandle = Ptr;

// Size of `__mpz_struct`.
c_SiZE_OF_MPZ : CInt;
c_SiZE_OF_MPZ = 16.to_CInt;

namespace MPZHandle {
    // Construct MPZHandle by GMP's initialization function, e.g., `mpz_init`.
    _construct_by : (MPZHandle -> IO a) -> IO (MPZHandle, a);
    _construct_by = |ctor| (
        let handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SiZE_OF_MPZ];
        let res = *ctor(handle);
        pure $ (handle, res)
    );

    // Calls `mpz_init_set`.
    _copy_constructor : MPZHandle -> IO MPZHandle;
    _copy_constructor = |handle| (
        let new_handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SiZE_OF_MPZ];
        FFI_CALL_IO[() __gmpz_init_set(Ptr, Ptr), new_handle, handle];;
        pure $ new_handle
    );

    // Calls `mpz_clear`.
    _destructor : MPZHandle -> IO MPZHandle;
    _destructor = |handle| (
        FFI_CALL_IO[() __gmpz_clear(Ptr), handle];;
        FFI_CALL_IO[() free(Ptr), handle];;
        pure $ nullptr
    );
}

// Integer type with arbitrary precision.
type MPZ = unbox struct { _0 : Destructor MPZHandle };

namespace MPZ {
    // Initialize a new MPZ using specified GMPZ's initialization action.
    _init_by : (MPZHandle -> IO a) -> (MPZ, a);
    _init_by = |ctor| do {
        let (handle, res) = *MPZHandle::_construct_by(ctor);
        pure $ (MPZ { _0 : Destructor::make(handle, MPZHandle::_destructor) }, res)
    }.unsafe_perform;

    // Performs an action with a borrowed pointer to the internal data.
    _borrow : (MPZHandle -> a) -> MPZ -> a;
    _borrow = |act, num| num.@_0.borrow(|handle| act(handle));

    // Acts on the internal data of the MPZ, which may mutate the MPZ value, and returns the mutated MPZ paired with the result of the action.
    _mutate : (MPZHandle -> IO a) -> MPZ -> (MPZ, a);
    _mutate = |act, num| (
        let dtor = num.@_0;
        let (dtor, res) = dtor.mutate_unique(MPZHandle::_copy_constructor, act);
        (MPZ { _0 : dtor }, res)
    );

    // Apply a unary operation of GMP (taking (out, in) as arguments) to a `MPZ` value.
    _unary_op : ((MPZHandle, MPZHandle) -> IO a) -> MPZ -> (MPZ, a);
    _unary_op = |act, num| (
        let (is_unique, num) = num.unsafe_is_unique;
        if is_unique {
            num._mutate(|num_ptr| act((num_ptr, num_ptr)))
        };
        num._borrow(|num_ptr|
            MPZ::zero._mutate(|out_ptr| act((out_ptr, num_ptr)))
        )
    );

    // Apply a unary operation of GMP (taking (out1, out2, in) as arguments) to a `MPZ` value.
    _unary_op2 : ((MPZHandle, MPZHandle, MPZHandle) -> IO a) -> MPZ -> (MPZ, MPZ, a);
    _unary_op2 = |act, num| (
        let (is_unique, num) = num.unsafe_is_unique;
        if is_unique {
            num._mutate(|num_ptr| 
                MPZ::zero._mutate(|out2_ptr|
                    act((num_ptr, out2_ptr, num_ptr))
                ).pure
            ).|(x, (y, z))| (x, y, z)
        };
        num._borrow(|num_ptr|
            MPZ::zero._mutate(|out1_ptr|
                MPZ::zero._mutate(|out2_ptr|
                    act((out1_ptr, out2_ptr, num_ptr))
                ).pure
            ).|(x, (y, z))| (x, y, z)
        )
    );

    // Apply a binary operation of GMP (taking (out, lhs, rhs) as arguments) to two `MPZ` values.
    _binary_op : ((MPZHandle, MPZHandle, MPZHandle) -> IO a) -> MPZ -> MPZ -> (MPZ, a);
    _binary_op = |act, lhs, rhs| (
        let (is_unique, lhs) = lhs.unsafe_is_unique;
        if is_unique { 
            rhs._borrow(|rhs_ptr|
                lhs._mutate(|lhs_ptr| act((lhs_ptr, lhs_ptr, rhs_ptr)))
            )
        };
        let (is_uqniue, rhs) = rhs.unsafe_is_unique;
        if is_unique { 
            lhs._borrow(|lhs_ptr|
                rhs._mutate(|rhs_ptr| act((rhs_ptr, lhs_ptr, rhs_ptr)))
            )
        };
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                MPZ::zero._mutate(|out_ptr| act((out_ptr, lhs_ptr, rhs_ptr)))
            )
        )
    );

    // Apply a binary operation which returns two values of GMP (taking (out0, out1, lhs, rhs) as arguments) to two `MPZ` values.
    _binary_op2 : ((MPZHandle, MPZHandle, MPZHandle, MPZHandle) -> IO a) -> MPZ -> MPZ -> (MPZ, MPZ, a);
    _binary_op2 = |act, lhs, rhs| (
        let (lhs_is_unique, lhs) = lhs.unsafe_is_unique;
        let (rhs_is_unique, rhs) = rhs.unsafe_is_unique;
        if lhs_is_unique && rhs_is_unique {
            lhs._mutate(|lhs_ptr| 
                rhs._mutate(|rhs_ptr|
                    act((lhs_ptr, rhs_ptr, lhs_ptr, rhs_ptr))
                ).pure
            ).|(x, (y, z))| (x, y, z)
        };
        if lhs_is_unique && !rhs_is_unique {
            rhs._borrow(|rhs_ptr|
                lhs._mutate(|lhs_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        act((lhs_ptr, out2_ptr, lhs_ptr, rhs_ptr))
                    ).pure
                ).|(x, (y, z))| (x, y, z)
            )
        };
        if !lhs_is_unique && rhs_is_unique {
            lhs._borrow(|lhs_ptr|
                rhs._mutate(|rhs_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        act((rhs_ptr, out2_ptr, lhs_ptr, rhs_ptr))
                    ).pure
                ).|(x, (y, z))| (x, y, z)
            )
        };
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                MPZ::zero._mutate(|out1_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        act((out1_ptr, out2_ptr, lhs_ptr, rhs_ptr))
                    ).pure
                ).|(x, (y, z))| (x, y, z)
            )
        )
    );

    // Apply a binary operation of GMP (taking (out1, out2, out3, op1, op2) as arguments) to two `MPZ` values.
    _binary_op3 : ((MPZHandle, MPZHandle, MPZHandle, MPZHandle, MPZHandle) -> IO a) -> MPZ -> MPZ -> (MPZ, MPZ, MPZ, a);
    _binary_op3 = |act, lhs, rhs| (
        let (lhs_is_unique, lhs) = lhs.unsafe_is_unique;
        let (rhs_is_unique, rhs) = rhs.unsafe_is_unique;
        if lhs_is_unique && rhs_is_unique {
            lhs._mutate(|lhs_ptr| 
                rhs._mutate(|rhs_ptr|
                    MPZ::zero._mutate(|out3_ptr|
                        act((lhs_ptr, rhs_ptr, out3_ptr, lhs_ptr, rhs_ptr))
                    ).pure
                ).pure
            ).|(x, (y, (z, w)))| (x, y, z, w)
        };
        if lhs_is_unique && !rhs_is_unique {
            rhs._borrow(|rhs_ptr|
                lhs._mutate(|lhs_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        MPZ::zero._mutate(|out3_ptr|
                            act((lhs_ptr, out2_ptr, out3_ptr, lhs_ptr, rhs_ptr))
                        ).pure
                    ).pure
                ).|(x, (y, (z, w)))| (x, y, z, w)
            )
        };
        if !lhs_is_unique && rhs_is_unique {
            lhs._borrow(|lhs_ptr|
                rhs._mutate(|rhs_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        MPZ::zero._mutate(|out3_ptr|
                            act((rhs_ptr, out2_ptr, out3_ptr, lhs_ptr, rhs_ptr))
                        ).pure
                    ).pure
                ).|(x, (y, (z, w)))| (x, y, z, w)
            )
        };
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                MPZ::zero._mutate(|out1_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        MPZ::zero._mutate(|out3_ptr|
                            act((out1_ptr, out2_ptr, out3_ptr, lhs_ptr, rhs_ptr))
                        ).pure
                    ).pure
                ).|(x, (y, (z, w)))| (x, y, z, w)
            )
        )
    );

    // Apply a tertiary operation of GMP (taking (out, op1, op2, op3) as arguments) to two `MPZ` values.
    _tertiary_op : ((MPZHandle, MPZHandle, MPZHandle, MPZHandle) -> IO ()) -> MPZ -> MPZ -> MPZ -> MPZ;
    _tertiary_op = |act, op1, op2, op3| (
        let (is_unique, op1) = op1.unsafe_is_unique;
        if is_unique {
            op2._borrow(|op2_ptr|
                op3._borrow(|op3_ptr|
                    op1._mutate(|op1_ptr| act((op1_ptr, op1_ptr, op2_ptr, op3_ptr))).@0
                )
            )
        };
        let (is_unique, op2) = op2.unsafe_is_unique;
        if is_unique {
            op1._borrow(|op1_ptr|
                op3._borrow(|op3_ptr|
                    op2._mutate(|op2_ptr| act((op2_ptr, op1_ptr, op2_ptr, op3_ptr))).@0
                )
            )
        };
        let (is_unique, op3) = op3.unsafe_is_unique;
        if is_unique {
            op1._borrow(|op1_ptr|
                op2._borrow(|op2_ptr|
                    op3._mutate(|op3_ptr| act((op3_ptr, op1_ptr, op2_ptr, op3_ptr))).@0
                )
            )
        };
        op1._borrow(|op1_ptr|
            op2._borrow(|op2_ptr|
                op3._borrow(|op3_ptr|
                    MPZ::zero._mutate(|out_ptr| act((out_ptr, op1_ptr, op2_ptr, op3_ptr))).@0
                )
            )
        )
    );
    
    // Create a `MPZ` value from an `I64`.
    // 
    // # Parameters
    // - `n`: The `I64` value to convert.
    mpz : I64 -> MPZ;
    mpz = MPZ::init_set_si;

    // The value `0`
    zero : MPZ;
    zero = MPZ::_init_by(|handle| FFI_CALL_IO[() __gmpz_init(Ptr), handle]).@0;

    // The value `1`
    one : MPZ;
    one = MPZ::init_set_si(1);

    // Sets the value of a MPZ to the given string in the given base.
    // 
    // If the string is not a valid representation of an integer in the given base, this function returns none.
    // See document of `mpz_set_str` in GMP for details.
    // 
    // # Parameters
    // - `str`: The string representation of the integer.
    // - `base`: The base of the string representation.
    // - `num`: The `MPZ` value to set.
    set_str : String -> I64 -> MPZ -> Option MPZ;
    set_str = |str, base, x| (
        str.borrow_c_str(|str_c_str| (
            let (x, res) = x._mutate(|ptr| 
                FFI_CALL_IO[CInt __gmpz_set_str(Ptr, Ptr, CInt), ptr, str_c_str, base.to_CInt]
            );
            if res == -1.to_CInt { Option::none() };
            Option::some $ x
        ))
    );

    // Creates a `MPZ` value represented by a string in the given base.
    // 
    // If the string is not a valid representation of an integer in the given base, this function returns none.
    // See document of `mpz_set_str` in GMP for details.
    // 
    // # Parameters
    // - `str`: The string representation of the integer.
    // - `base`: The base of the string representation.
    init_set_str : String -> I64 -> Option MPZ;
    init_set_str = |str, base| (
        str.borrow_c_str(|str_c_str| (
            let (num, res) = MPZ::_init_by(|ptr| 
                FFI_CALL_IO[CInt __gmpz_init_set_str(Ptr, Ptr, CInt), ptr, str_c_str, base.to_CInt]
            );
            if res == -1.to_CInt { Option::none() };
            Option::some $ num
        ))
    );

    // Sets the value of a MPZ to the given I64 value.
    // 
    // # Parameters
    // - `val`: The I64 value to set.
    // - `x`: The `MPZ` value to set.
    set_si : I64 -> MPZ -> MPZ;
    set_si = |val, x| (
        x._mutate(|ptr| FFI_CALL_IO[() __gmpz_set_si(Ptr, CLong), ptr, val]).@0
    );

    // Creates a `MPZ` value represented by an I64 value.
    // 
    // # Parameters
    // - `val`: The I64 value to represent.
    init_set_si : I64 -> MPZ;
    init_set_si = |val| MPZ::_init_by(|ptr| FFI_CALL_IO[() __gmpz_init_set_si(Ptr, CLong), ptr, val]).@0;
   
    // Sets the value of a MPZ to the given U64 value.
    // 
    // # Parameters
    // - `val`: The U64 value to set.
    // - `x`: The `MPZ` value to set.
    set_ui : U64 -> MPZ -> MPZ;
    set_ui = |val, x| (
        x._mutate(|ptr| FFI_CALL_IO[() __gmpz_set_ui(Ptr, CUnsignedLong), ptr, val]).@0
    );

    // Creates a `MPZ` value represented by an U64 value.
    // 
    // # Parameters
    // - `val`: The U64 value to represent.
    init_set_ui : U64 -> MPZ;
    init_set_ui = |val| MPZ::_init_by(|ptr| FFI_CALL_IO[() __gmpz_init_set_ui(Ptr, CUnsignedLong), ptr, val]).@0;

    // Sets the value of a MPZ to the integer part of a F64 value.
    set_d : F64 -> MPZ -> MPZ;
    set_d = |val, x| (
        x._mutate(|ptr| FFI_CALL_IO[() __gmpz_set_d(Ptr, CDouble), ptr, val]).@0
    );

    // Creates a `MPZ` value represented by a F64 value.
    // 
    // # Parameters
    // - `val`: The F64 value to represent.
    init_set_d : F64 -> MPZ;
    init_set_d = |val| MPZ::_init_by(|ptr| FFI_CALL_IO[() __gmpz_init_set_d(Ptr, CDouble), ptr, val]).@0;

    // Sets the value of a MPZ to the integer part of a MPQ value.
    // 
    // # Parameters
    // - `q`: The `MPQ` value to set.
    // - `x`: The `MPZ` value to set.
    set_q : MPQ -> MPZ -> MPZ;
    set_q = |q, x| (
        q._borrow(|q_ptr| (
            x._mutate(|x_ptr| (
                FFI_CALL_IO[() __gmpz_set_q(Ptr, Ptr), x_ptr, q_ptr]
            )).@0
        ))
    );

    // Converts a `MPZ` value to an I64 value.
    // 
    // If the value is too large to fit in an I64, this function returns none.
    get_si : MPZ -> Option I64;
    get_si = |num| (
        num._borrow(|num_ptr| (
            let fits = FFI_CALL[CInt __gmpz_fits_slong_p(Ptr), num_ptr];
            if fits == 0.to_CInt { Option::none() };
            let res = FFI_CALL[CLong __gmpz_get_si(Ptr), num_ptr];
            Option::some $ res.to_I64
        ))
    );

    // Converts a `MPZ` value to an U64 value.
    //
    // If the value is too large to fit in an U64, this function returns none.
    get_ui : MPZ -> Option U64;
    get_ui = |num| (
        num._borrow(|num_ptr| (
            let fits = FFI_CALL[CInt __gmpz_fits_ulong_p(Ptr), num_ptr];
            if fits == 0.to_CInt { Option::none() };
            let res = FFI_CALL[CUnsignedLong __gmpz_get_ui(Ptr), num_ptr];
            Option::some $ res
        ))
    );

    // Converts a `MPZ` value to an F64 value.
    //
    // For details, see the document of `mpz_get_d` in GMP.
    get_d : MPZ -> F64;
    get_d = |num| (
        num._borrow(|num_ptr| (
            FFI_CALL[CDouble __gmpz_get_d(Ptr), num_ptr].to_F64
        ))
    );

    // Converts a `MPZ` value to the pair (F64 value, exponent).
    // 
    // For details, see the document of `mpz_get_d_2exp` in GMP.
    get_d_exp : MPZ -> (F64, I64);
    get_d_exp = |num| (
        let exp = Box::make(0.to_CLong);
        let (exp, man) = num._borrow(|num_ptr| exp.mutate_boxed(|exp_ptr| 
            FFI_CALL_IO[CDouble __gmpz_get_d_2exp(Ptr, Ptr), exp_ptr, num_ptr]
        ));
        (man, exp.@value.to_I64)
    );

    // Get the string representation of a `MPZ` value in the given base.
    // 
    // # Parameters
    // - `base`: The base of the string representation, which must be in the range [-36, -2] or [2, 62].
    // - `num`: The `MPZ` value to convert.
    get_str : I64 -> MPZ -> String;
    get_str = |base, num| (
        if !(-36 <= base && base <= -2 || 2 <= base && base <= 62) {
            undefined("[MPZ::get_str] `base` must be in the range [-36, -2] or [2, 62]")
        };
        let base = base.to_CInt;        
        num._borrow(|x_ptr| (
            let str_ptr = FFI_CALL[Ptr __gmpz_get_str(Ptr, CInt, Ptr), nullptr, base.to_CInt, x_ptr];
            let str = String::_unsafe_from_c_str_ptr(str_ptr);
            FFI_CALL_IO[() free(Ptr), str_ptr];;
            str.pure
        ).unsafe_perform)
    );

    // Calculates the absolute value of a `MPZ` value.
    // 
    // # Parameters
    // - `num`: The `MPZ` value to calculate the absolute value of.
    abs : MPZ -> MPZ;
    abs = |num| num._unary_op(|(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpz_abs(Ptr, Ptr), out_ptr, in_ptr]).@0;

    // Multiplication by a power of 2.
    mul_2exp : U64 -> MPZ -> MPZ;
    mul_2exp = |exp, num| (
        num._unary_op(|(out_ptr, num_ptr)| FFI_CALL_IO[() __gmpz_mul_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, num_ptr, exp.to_CUnsignedLong]).@0
    );

    // Exact Divisions

    // Checks if `n` is divisible by `d`.
    //
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    divisible_p : MPZ -> MPZ -> Bool;
    divisible_p = |d, n| (
        d._borrow(|d_ptr| (
            n._borrow(|n_ptr| (
                FFI_CALL[CInt __gmpz_divisible_p(Ptr, Ptr), n_ptr, d_ptr] != 0.to_CInt
            ))
        ))
    );

    // Checks if `n` is divisible by `2^b`.
    //
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    divisible_2exp_p : U64 -> MPZ -> Bool;
    divisible_2exp_p = |bit, n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CInt __gmpz_divisible_2exp_p(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong] != 0.to_CInt
        ))
    );

    // Divides `n` by `d` and returns the quotient.
    // 
    // This function assumes that `n` is divisible by `d`.
    //
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    divexact : MPZ -> MPZ -> MPZ;
    divexact = |d, n| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_divexact(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            n, d
        ).@0
    );

    // Modulo

    // Calculates the remainder of `n` divided by `d`.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    mod : MPZ -> MPZ -> MPZ;
    mod = |d, n| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_mod(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            n, d
        ).@0
    );

    // Checks if two values `a`, `b` are congruent modulo `m`.
    //
    // # Parameters
    // - `m`: The modulus.
    // - `a`: The first value.
    // - `b`: The second value.
    congruent_p : MPZ -> MPZ -> MPZ -> Bool;
    congruent_p = |m, a, b| (
        a._borrow(|a_ptr| (
            b._borrow(|b_ptr| (
                m._borrow(|m_ptr| (
                    FFI_CALL[CInt __gmpz_congruent_p(Ptr, Ptr, Ptr), a_ptr, b_ptr, m_ptr] != 0.to_CInt
                ))
            ))
        ))
    );

    // Checks if two values `a`, `b` are congruent modulo `2^b`.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `a`: The first value.
    // - `b`: The second value.
    congruent_2exp_p : U64 -> MPZ -> MPZ -> Bool;
    congruent_2exp_p = |bit, a, b| (
        a._borrow(|a_ptr| (
            b._borrow(|b_ptr| (
                FFI_CALL[CInt __gmpz_congruent_2exp_p(Ptr, Ptr, CUnsignedLong), a_ptr, b_ptr, bit.to_CUnsignedLong] != 0.to_CInt
            ))
        ))
    );

    // Division and remainder

    // Divides `n` by `d` and returns the quotient and remainder.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    tdiv_qr : MPZ -> MPZ -> (MPZ, MPZ);
    tdiv_qr = |d, n| (
        MPZ::_binary_op2(
            |(q_ptr, r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_tdiv_qr(Ptr, Ptr, Ptr, Ptr), q_ptr, r_ptr, n_ptr, d_ptr],
            n, d
        ).|(x, y, _)| (x, y)
    );

    // Divides `n` by `d` and returns the quotient.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    tdiv_q : MPZ -> MPZ -> MPZ;
    tdiv_q = |d, n| (
        MPZ::_binary_op(
            |(q_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_tdiv_q(Ptr, Ptr, Ptr), q_ptr, n_ptr, d_ptr],
            n, d
        ).@0
    );

    // Divides `n` by `d` and returns the remainder.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    tdiv_r : MPZ -> MPZ -> MPZ;
    tdiv_r = |d, n| (
        MPZ::_binary_op(
            |(r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_tdiv_r(Ptr, Ptr, Ptr), r_ptr, n_ptr, d_ptr],
            n, d
        ).@0
    );

    // Divides `n` by `2^b` and returns the quotient.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    tdiv_q_2exp : U64 -> MPZ -> MPZ;
    tdiv_q_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_tdiv_q_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        ).@0
    );

    // Divides `n` by `2^b` and returns the remainder.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    tdiv_r_2exp : U64 -> MPZ -> MPZ;
    tdiv_r_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_tdiv_r_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        ).@0
    );

    // Divides `n` by `d` and returns the quotient and remainder.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    fdiv_qr : MPZ -> MPZ -> (MPZ, MPZ);
    fdiv_qr = |d, n| (
        MPZ::_binary_op2(
            |(q_ptr, r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_fdiv_qr(Ptr, Ptr, Ptr, Ptr), q_ptr, r_ptr, n_ptr, d_ptr],
            n, d
        ).|(x, y, _)| (x, y)
    );

    // Divides `n` by `d` and returns the quotient.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    fdiv_q : MPZ -> MPZ -> MPZ;
    fdiv_q = |d, n| (
        MPZ::_binary_op(
            |(q_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_fdiv_q(Ptr, Ptr, Ptr), q_ptr, n_ptr, d_ptr],
            n, d
        ).@0
    );

    // Divides `n` by `d` and returns the remainder.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    fdiv_r : MPZ -> MPZ -> MPZ;
    fdiv_r = |d, n| (
        MPZ::_binary_op(
            |(r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_fdiv_r(Ptr, Ptr, Ptr), r_ptr, n_ptr, d_ptr],
            n, d
        ).@0
    );

    // Divides `n` by `2^b` and returns the quotient.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    fdiv_q_2exp : U64 -> MPZ -> MPZ;
    fdiv_q_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_fdiv_q_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        ).@0
    );

    // Divides `n` by `2^b` and returns the remainder.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    fdiv_r_2exp : U64 -> MPZ -> MPZ;
    fdiv_r_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_fdiv_r_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        ).@0
    );

    // Divides `n` by `d` and returns the quotient and remainder.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    cdiv_qr : MPZ -> MPZ -> (MPZ, MPZ);
    cdiv_qr = |d, n| (
        MPZ::_binary_op2(
            |(q_ptr, r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_cdiv_qr(Ptr, Ptr, Ptr, Ptr), q_ptr, r_ptr, n_ptr, d_ptr],
            n, d
        ).|(x, y, _)| (x, y)
    );

    // Divides `n` by `d` and returns the quotient.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    cdiv_q : MPZ -> MPZ -> MPZ;
    cdiv_q = |d, n| (
        MPZ::_binary_op(
            |(q_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_cdiv_q(Ptr, Ptr, Ptr), q_ptr, n_ptr, d_ptr],
            n, d
        ).@0
    );

    // Divides `n` by `d` and returns the remainder.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    cdiv_r : MPZ -> MPZ -> MPZ;
    cdiv_r = |d, n| (
        MPZ::_binary_op(
            |(r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_cdiv_r(Ptr, Ptr, Ptr), r_ptr, n_ptr, d_ptr],
            n, d
        ).@0
    );

    // Divides `n` by `2^b` and returns the quotient.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    cdiv_q_2exp : U64 -> MPZ -> MPZ;
    cdiv_q_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_cdiv_q_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        ).@0
    );

    // Divides `n` by `2^b` and returns the remainder.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    cdiv_r_2exp : U64 -> MPZ -> MPZ;
    cdiv_r_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_cdiv_r_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        ).@0
    );

    // Calculates `x + a * b`.
    // 
    // # Parameters
    // - `a`
    // - `b`
    // - `x`
    addmul : MPZ -> MPZ -> MPZ -> MPZ;
    addmul = |op1, op2, rop| (
        op1._borrow(|op1_ptr| (
            op2._borrow(|op2_ptr| (
                rop._mutate(|rop_ptr| (
                    FFI_CALL_IO[() __gmpz_addmul(Ptr, Ptr, Ptr), rop_ptr, op1_ptr, op2_ptr]
                )).@0
            ))
        ))
    );

    // Calculates `x - a * b`.
    // 
    // # Parameters
    // - `a`
    // - `b`
    // - `x`
    submul : MPZ -> MPZ -> MPZ -> MPZ;
    submul = |op1, op2, rop| (
        op1._borrow(|op1_ptr| (
            op2._borrow(|op2_ptr| (
                rop._mutate(|rop_ptr| (
                    FFI_CALL_IO[() __gmpz_submul(Ptr, Ptr, Ptr), rop_ptr, op1_ptr, op2_ptr]
                )).@0
            ))
        ))
    );

    // Power

    // Calculates `b^e mod m`.
    // 
    // # Parameters
    // - `e`: The exponent.
    // - `m`: The modulus.
    // - `b`: The base.
    powm : MPZ -> MPZ -> MPZ -> MPZ;
    powm = |exp, mod, base| (
        MPZ::_tertiary_op(
            |(out_ptr, base_ptr, exp_ptr, mod_ptr)| FFI_CALL_IO[() __gmpz_powm(Ptr, Ptr, Ptr, Ptr), out_ptr, base_ptr, exp_ptr, mod_ptr],
            base, exp, mod
        )
    );

    // Calculates `b^e mod m`.
    // 
    // This is a secure version of `powm`. For details, see the document of `mpz_powm_sec` in GMP.
    // 
    // # Parameters
    // - `e`: The exponent.
    // - `m`: The modulus.
    // - `b`: The base.
    powm_sec : MPZ -> MPZ -> MPZ -> MPZ;
    powm_sec = |exp, mod, base| (
        MPZ::_tertiary_op(
            |(out_ptr, base_ptr, exp_ptr, mod_ptr)| FFI_CALL_IO[() __gmpz_powm(Ptr, Ptr, Ptr, Ptr), out_ptr, base_ptr, exp_ptr, mod_ptr],
            base, exp, mod
        )
    );    

    // Calculates `b^e`.
    // 
    // # Parameters
    // - `e`: The exponent.
    // - `b`: The base.
    pow_ui : U64 -> MPZ -> MPZ;
    pow_ui = |exp, base| (
        MPZ::_unary_op(
            |(out_ptr, base_ptr)| FFI_CALL_IO[() __gmpz_pow_ui(Ptr, Ptr, CUnsignedLong), out_ptr, base_ptr, exp.to_CUnsignedLong],
            base
        ).@0
    );

    // Roots

    // Calculates the integer part of the n-th root of `x`.
    // 
    // # Parameters
    // - `n`: The root to calculate.
    // - `x`: The value to calculate the root of.
    root : U64 -> MPZ -> MPZ;
    root = |n, x| (
        MPZ::_unary_op(
            |(out_ptr, op_ptr)| FFI_CALL_IO[() __gmpz_root(Ptr, Ptr, CUnsignedLong), out_ptr, op_ptr, n.to_CUnsignedLong],
            x
        ).@0
    );

    // Calculates the n-th root of `x` and the remainder.
    // 
    // # Returns
    // A pair (root, remainder) such that `x = root^n + remainder`.
    // 
    // # Parameters
    // - `n`: The root to calculate.
    // - `x`: The value to calculate the root of.
    root_rem : U64 -> MPZ -> (MPZ, MPZ);
    root_rem = |n, x| (
        MPZ::_unary_op2(
            |(out_ptr, rem_ptr, op_ptr)| FFI_CALL_IO[() __gmpz_rootrem(Ptr, Ptr, Ptr, CUnsignedLong), out_ptr, rem_ptr, op_ptr, n.to_CUnsignedLong],
            x
        ).|(x, y, _)| (x, y)
    );

    // Calculates the integer part of the root of `x` and the remainder.
    //
    // # Parameters
    // - `x`: The value to calculate the root of.
    sqrt : MPZ -> MPZ;
    sqrt = |x| (
        MPZ::_unary_op(
            |(out_ptr, op_ptr)| FFI_CALL_IO[() __gmpz_sqrt(Ptr, Ptr), out_ptr, op_ptr],
            x
        ).@0
    );

    // Calculates the square root of `x` and the remainder.
    // 
    // # Returns
    // A pair (root, remainder) such that `x = root^2 + remainder
    //
    // # Parameters
    // - `x`: The value to calculate the square root of.
    sqrt_rem : MPZ -> (MPZ, MPZ);
    sqrt_rem = |x| (
        MPZ::_unary_op2(
            |(out_ptr, rem_ptr, op_ptr)| FFI_CALL_IO[() __gmpz_sqrtrem(Ptr, Ptr, Ptr), out_ptr, rem_ptr, op_ptr],
            x
        ).|(x, y, _)| (x, y)
    );

    // Checks if `x` is a perfect power, i.e., `x = a^b` for some integers `a` and `b >= 2`.
    perfect_power_p : MPZ -> Bool;
    perfect_power_p = |x| (
        x._borrow(|x_ptr| (
            FFI_CALL[CInt __gmpz_perfect_power_p(Ptr), x_ptr] != 0.to_CInt
        ))
    );

    // Checks if `x` is a perfect square, i.e., `x = a^2` for some integer `a`.
    perfect_square_p : MPZ -> Bool;
    perfect_square_p = |x| (
        x._borrow(|x_ptr| (
            FFI_CALL[CInt __gmpz_perfect_square_p(Ptr), x_ptr] != 0.to_CInt
        ))
    );

    // Number theoretic functions

    // Checks if `x` is a prime number.
    // 
    // # Returns 
    // 2 if `x` is definitely prime, 1 if it is probably prime, and 0 if it is definitely composite.
    // 
    // # Parameters
    // - `k`: The number of iterations to perform for the probabilistic test.
    // - `x`: The value to check.
    probab_prime_p : I64 -> MPZ -> I64;
    probab_prime_p = |k, x| (
        x._borrow(|x_ptr| (
            FFI_CALL[CInt __gmpz_probab_prime_p(Ptr, CInt), x_ptr, k.to_CInt].to_I64
        ))
    );

    // Calculates (probabilistically) the next prime number greater than `x`.
    // 
    // # Parameters
    // - `x`: The value to find the next prime of.
    nextprime : MPZ -> MPZ;
    nextprime = |x| (
        x._unary_op(|(out_ptr, x_ptr)| FFI_CALL_IO[() __gmpz_nextprime(Ptr, Ptr), out_ptr, x_ptr]).@0
    );

    // Calculates the greatest common divisor of two `MPZ` values.
    // 
    // # Parameters
    // - `n`
    // - `m`
    gcd : MPZ -> MPZ -> MPZ;
    gcd = |n, m| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_gcd(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            n, m
        ).@0
    );

    // Calculates the greatest common divisor `gcd` of two `MPZ` values and also returns coefficients `s` and `t` such that `gcd = n * s + m * t`.
    // 
    // # Returns
    // A tuple `(gcd, s, t)`
    // 
    // # Parameters
    // - `n`: The first value.
    // - `m`: The second value.
    gcdext : MPZ -> MPZ -> (MPZ, MPZ, MPZ);
    gcdext = |n, m| (
        MPZ::_binary_op3(
            |(out_ptr, s_ptr, t_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_gcdext(Ptr, Ptr, Ptr, Ptr, Ptr), out_ptr, s_ptr, t_ptr, lhs_ptr, rhs_ptr],
            n, m
        ).|(x, y, z, _)| (x, y, z)
    );

    // Calculates the least common multiple of two `MPZ` values.
    // 
    // # Parameters
    // - `n`: The first value.
    // - `m`: The second value.
    lcm : MPZ -> MPZ -> MPZ;
    lcm = |n, m| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_lcm(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            n, m
        ).@0
    );

    // Calculates the modular inverse of `n` modulo `m`.
    // 
    // # Parameters
    // - `m`: The modulus.
    // - `n`: The value to invert.
    invert : MPZ -> MPZ -> Option MPZ;
    invert = |m, n| (
        let (inv, flag) = MPZ::_binary_op(
            |(inv_ptr, n_ptr, m_ptr)| FFI_CALL_IO[CInt __gmpz_invert(Ptr, Ptr, Ptr), inv_ptr, n_ptr, m_ptr],
            n, m
        );
        if flag == 0.to_CInt {
            Option::none()
        } else {
            Option::some(inv)
        }
    );

    // Calculates the Jacobi symbol (a/b) for two `MPZ` values.
    // 
    // # Parameters
    // - `a`
    // - `b`
    jacobi : MPZ -> MPZ -> I64;
    jacobi = |b, a| (
        b._borrow(|b_ptr| (
            a._borrow(|a_ptr| (
                FFI_CALL[CInt __gmpz_jacobi(Ptr, Ptr), a_ptr, b_ptr].to_I64
            ))
        ))
    );

    // Calculates the Legendre symbol (a/p) for an `MPZ` value `a` and a prime `p`.
    // 
    // # Parameters
    // - `a`: The value to calculate the Legendre symbol for.
    // - `p`: The prime number.
    legendre : MPZ -> MPZ -> I64;
    legendre = |a, p| (
        a._borrow(|a_ptr| (
            p._borrow(|p_ptr| (
                FFI_CALL[CInt __gmpz_legendre(Ptr, Ptr), a_ptr, p_ptr].to_I64
            ))
        ))
    );

    // Removes the factor `f` from `n`.
    // 
    // # Returns
    // A tuple `(m, count)` where `m` is the result and `count` is the number of times `f` was removed from `n`.
    //
    // # Parameters
    // - `f`: The factor to remove.
    // - `n`: The value to remove the factor from.
    remove : MPZ -> MPZ -> (MPZ, U64);
    remove = |f, n| (
        MPZ::_binary_op(
            |(out_ptr, n_ptr, f_ptr)| FFI_CALL_IO[CUnsignedLong __gmpz_remove(Ptr, Ptr, Ptr), out_ptr, n_ptr, f_ptr].map(to_U64),
            n, f
        )
    );

    // Calculates the factorial of a non-negative integer `n`.
    // 
    // # Parameters
    // - `n`: The non-negative integer to calculate the factorial of.
    fac_ui : U64 -> MPZ;
    fac_ui = |n| (
        MPZ::zero._mutate(
            |out_ptr| FFI_CALL_IO[() __gmpz_fac_ui(Ptr, CUnsignedLong), out_ptr, n.to_CUnsignedLong]
        ).@0
    );

    // Calculates the double factorial of a non-negative integer `n`.
    // 
    // # Parameters
    // - `n`: The non-negative integer to calculate the double factorial of.
    fac2_ui : U64 -> MPZ;
    fac2_ui = |n| (
        MPZ::zero._mutate(
            |out_ptr| FFI_CALL_IO[() __gmpz_2fac_ui(Ptr, CUnsignedLong), out_ptr, n.to_CUnsignedLong]
        ).@0
    );

    // Calculates the factorial of `n!^(m)` 
    // 
    // # Parameters
    // - `m`
    // - `n`: The non-negative integer to calculate the factorial of.
    facm_uiui : U64 -> U64 -> MPZ;
    facm_uiui = |m, n| (
        MPZ::zero._mutate(
            |out_ptr| FFI_CALL_IO[() __gmpz_mfac_uiui(Ptr, CUnsignedLong, CUnsignedLong), out_ptr, n.to_CUnsignedLong, m.to_CUnsignedLong]
        ).@0
    );

    // Calculates the primorial of a non-negative integer `n`, which is the product of all prime numbers less than or equal to `n`.
    // 
    // # Parameters
    // - `n`
    primorial_ui : U64 -> MPZ;
    primorial_ui = |n| (
        MPZ::zero._mutate(
            |out_ptr| FFI_CALL_IO[() __gmpz_primorial_ui(Ptr, CUnsignedLong), out_ptr, n.to_CUnsignedLong]
        ).@0
    );

    // Calculates the binomial coefficient `n choose k`.
    // 
    // # Parameters
    // - `k`: The number of items to choose.
    // - `n`: The total number of items.
    bin_ui : MPZ -> U64 -> MPZ;
    bin_ui = |n, k| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_bin_ui(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, k.to_CUnsignedLong],
            n
        ).@0
    );

    // Calculates the Fibonacci number at position `n`.
    // 
    // # Parameters
    // - `n`: The position in the Fibonacci sequence.
    fib_ui : U64 -> MPZ;
    fib_ui = |n| (
        MPZ::zero._mutate(
            |out_ptr| FFI_CALL_IO[() __gmpz_fib_ui(Ptr, CUnsignedLong), out_ptr, n.to_CUnsignedLong]
        ).@0
    );

    // Calculates the Fibonacci number at position `n` and returns both the Fibonacci number and the previous one.
    // 
    // # Parameters
    // - `n`: The position in the Fibonacci sequence.
    fib2_ui : U64 -> (MPZ, MPZ);
    fib2_ui = |n| (
        MPZ::zero._mutate(|out_ptr|
            MPZ::zero._mutate(|out_prev_ptr|
                FFI_CALL_IO[() __gmpz_fib2_ui(Ptr, Ptr, CUnsignedLong), out_ptr, out_prev_ptr, n.to_CUnsignedLong]
            ).@0.pure
        )
    );

    // Calculates the Lucas number at position `n`.
    // 
    // # Parameters
    // - `n`: The position in the Lucas sequence.
    lucnum_ui : U64 -> MPZ;
    lucnum_ui = |n| (
        MPZ::zero._mutate(
            |out_ptr| FFI_CALL_IO[() __gmpz_lucnum_ui(Ptr, CUnsignedLong), out_ptr, n.to_CUnsignedLong]
        ).@0
    );

    // Calculates the Lucas number at position `n` and returns both the Lucas number and the previous one.
    // 
    // # Parameters
    // - `n`: The position in the Lucas sequence.
    lucnum2_ui : U64 -> (MPZ, MPZ);
    lucnum2_ui = |n| (
        MPZ::zero._mutate(|out_ptr|
            MPZ::zero._mutate(|out_prev_ptr|
                FFI_CALL_IO[() __gmpz_lucnum2_ui(Ptr, Ptr, CUnsignedLong), out_ptr, out_prev_ptr, n.to_CUnsignedLong]
            ).@0.pure
        )
    );

    // Comparisons

    // Compares two `MPZ` values.
    // 
    // # Returns
    // - a negative if `lhs < rhs`
    // - zero if `lhs == rhs`
    // - a positive if `lhs > rhs`
    //
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    cmp : MPZ -> MPZ -> I64;
    cmp = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[CInt __gmpz_cmp(Ptr, Ptr), lhs_ptr, rhs_ptr].to_I64
            ))
        ))
    );

    // Compares a `MPZ` value and an `F64` value.
    // 
    // # Returns
    // - a negative if `lhs < rhs`
    // - zero if `lhs == rhs`
    // - a positive if `lhs > rhs`
    //
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    cmp_d : MPZ -> F64 -> I64;
    cmp_d = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            FFI_CALL[CInt __gmpz_cmp_d(Ptr, CDouble), lhs_ptr, rhs].to_I64
        ))
    );

    // Compares absolute values of two `MPZ` values.
    // 
    // # Returns
    // - a negative if `|lhs| < |rhs|`
    // - zero if `|lhs| == |rhs|`
    // - a positive if `|lhs| > |rhs|`
    //
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    cmpabs : MPZ -> MPZ -> I64;
    cmpabs = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[CInt __gmpz_cmpabs(Ptr, Ptr), lhs_ptr, rhs_ptr].to_I64
            ))
        ))
    );

    // Compares absolute values of a `MPZ` value and an `F64` value.
    // 
    // # Returns
    // - a negative if `|lhs| < |rhs|`
    // - zero if `|lhs| == |rhs|`
    // - a positive if `|lhs| > |rhs|`
    //
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    cmpabs_d : MPZ -> F64 -> I64;
    cmpabs_d = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            FFI_CALL[CInt __gmpz_cmpabs_d(Ptr, CDouble), lhs_ptr, rhs].to_I64
        ))
    );

    // Returns the sign of a `MPZ` value.
    // 
    // # Returns
    // - `-1` if `n < 0`
    // - `0` if `n == 0`
    // - `1` if `n > 0`
    sgn : MPZ -> I64;
    sgn = |n| (
        let r = MPZ::cmp(n, MPZ::zero);
        if r < 0 { -1 };
        if r > 0 { 1 };
        0
    );

    // Bit operations

    // Logical and operation on two `MPZ` values.
    // 
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    and : MPZ -> MPZ -> MPZ;
    and = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_and(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );

    // Logical or operation on two `MPZ` values.
    // 
    // # Parameters
    // - `lhs`: The left-hand-side value.
    // - `rhs`: The right-hand-side value.
    or : MPZ -> MPZ -> MPZ;
    or = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_ior(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );

    // Logical xor operation on two `MPZ` values.
    // 
    // # Parameters
    // - `lhs`: The left-hand-side value.
    // - `rhs`: The right-hand-side value.
    xor : MPZ -> MPZ -> MPZ;
    xor = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_xor(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );

    // Bitwise complement operation on a `MPZ` value.
    //
    // # Parameters
    // - `n`: The `MPZ` value to complement.
    com : MPZ -> MPZ;
    com = |n| (
        MPZ::_unary_op(
            |(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpz_com(Ptr, Ptr), out_ptr, in_ptr],
            n
        ).@0
    );

    // Counts the number of bits set to `1` in a `MPZ` value.
    // 
    // For the behavior when `n` is negative, see the document of `mpz_popcount` in GMP.
    // 
    // # Parameters
    // - `n`: The `MPZ` value to count bits in.
    popcount : MPZ -> U64;
    popcount = |n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CUnsignedLong __gmpz_popcount(Ptr), n_ptr].to_U64
        ))
    );

    // Calculates the Hamming distance between two `MPZ` values.
    // 
    // For the behavior when `lhs` or `rhs` is negative, see the document of `mpz_hamdist` in GMP.
    // 
    // # Parameters
    // - `lhs`: The left-hand-side value.
    // - `rhs`: The right-hand-side value.
    hamdist : MPZ -> MPZ -> U64;
    hamdist = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[CUnsignedLong __gmpz_hamdist(Ptr, Ptr), lhs_ptr, rhs_ptr].to_U64
            ))
        ))
    );

    // Scans `0` bit in a `MPZ` value starting from the specified bit.
    // 
    // # Parameters
    // - `bit`: The bit to start scanning from.
    // - `n`: The `MPZ` value to scan.
    scan0 : U64 -> MPZ -> U64;
    scan0 = |bit, n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CUnsignedLong __gmpz_scan0(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong].to_U64
        ))
    );

    // Scans `1` bit in a `MPZ` value starting from the specified bit.
    // 
    // # Parameters
    // - `bit`: The bit to start scanning from.
    // - `n`: The `MPZ` value to scan.
    scan1 : U64 -> MPZ -> U64;
    scan1 = |bit, n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CUnsignedLong __gmpz_scan1(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong].to_U64
        ))
    );

    // Sets the specified bit in a `MPZ` value to `1`.
    // 
    // # Parameters
    // - `bit`: The bit to set.
    // - `n`: The `MPZ` value to modify.
    setbit : U64 -> MPZ -> MPZ;
    setbit = |bit, n| (
        n._mutate(|n_ptr| (
            FFI_CALL_IO[() __gmpz_setbit(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong]
        )).@0
    );

    // Sets the specified bit in a `MPZ` value to `0`.
    // 
    // # Parameters
    // - `bit`: The bit to clear.
    // - `n`: The `MPZ` value to modify.
    clrbit : U64 -> MPZ -> MPZ;
    clrbit = |bit, n| (
        n._mutate(|n_ptr| (
            FFI_CALL_IO[() __gmpz_clrbit(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong]
        )).@0
    );

    // Toggles the specified bit in a `MPZ` value.
    //
    // # Parameters
    // - `bit`: The bit to toggle.
    // - `n`: The `MPZ` value to modify.
    combit : U64 -> MPZ -> MPZ;
    combit = |bit, n| (
        n._mutate(|n_ptr| (
            FFI_CALL_IO[() __gmpz_combit(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong]
        )).@0
    );

    // Checks if the specified bit in a `MPZ` value is set to `1`.
    // 
    // # Parameters
    // - `bit`: The bit to check.
    // - `n`: The `MPZ` value to check.
    tstbit : U64 -> MPZ -> Bool;
    tstbit = |bit, n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CInt __gmpz_tstbit(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong] != 0.to_CInt
        ))
    );
}

impl MPZ : Add {
    add = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_add(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPZ : Sub {
    sub = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_sub(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPZ : Mul {
    mul = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_mul(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPZ : Neg {
    neg = |num| (
        num._unary_op(|(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpz_neg(Ptr, Ptr), out_ptr, in_ptr]).@0
    );
}

impl MPZ : Eq {
    eq = |lhs, rhs| MPZ::cmp(lhs, rhs) == 0;
}

impl MPZ : Rem {
    rem = |n, d| n.MPZ::tdiv_r(d);
}

impl MPZ : Div {
    div = |n, d| n.MPZ::tdiv_q(d);
}

impl MPZ : LessThan {
    less_than = |lhs, rhs| MPZ::cmp(lhs, rhs) < 0;
}

impl MPZ : LessThanOrEq {
    less_than_or_eq = |lhs, rhs| MPZ::cmp(lhs, rhs) <= 0;
}

impl MPZ : ToString {
    to_string = |num| num.get_str(10);
}

impl MPZ : FromString {
    from_string = |s| match MPZ::init_set_str(s, 10) {
        none() => err $ "Failed to parse MPZ as a decimal string",
        some(value) => ok $ value
    };
}

impl MPZ : Hash {
    hash = to_string >> hash;
}