module GMP.Z;

import Hash;
import GMP.Q;

// A pointer to struct `__mpz_struct`.
type MPZHandle = Ptr;

// Size of `__mpz_struct`.
c_SiZE_OF_MPZ : CInt;
c_SiZE_OF_MPZ = 16.to_CInt;

namespace MPZHandle {
    // Construct MPZHandle by GMP's initialization function, e.g., `mpz_init`.
    _construct_by : (MPZHandle -> IO a) -> IO (MPZHandle, a);
    _construct_by = |ctor| (
        let handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SiZE_OF_MPZ];
        let res = *ctor(handle);
        pure $ (handle, res)
    );

    // Calls `mpz_init_set`.
    _copy_constructor : MPZHandle -> IO MPZHandle;
    _copy_constructor = |handle| (
        let new_handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SiZE_OF_MPZ];
        FFI_CALL_IO[() __gmpz_init_set(Ptr, Ptr), new_handle, handle];;
        pure $ new_handle
    );

    // Calls `mpz_clear`.
    _destructor : MPZHandle -> IO MPZHandle;
    _destructor = |handle| (
        FFI_CALL_IO[() __gmpz_clear(Ptr), handle];;
        FFI_CALL_IO[() free(Ptr), handle];;
        pure $ nullptr
    );
}

// Integer type with arbitrary precision.
type MPZ = unbox struct { _0 : Destructor MPZHandle };

namespace MPZ {
    // Initialize a new MPZ using specified GMPZ's initialization action.
    _init_by : (MPZHandle -> IO a) -> (MPZ, a);
    _init_by = |ctor| do {
        let (handle, res) = *MPZHandle::_construct_by(ctor);
        pure $ (MPZ { _0 : Destructor::make(handle, MPZHandle::_destructor) }, res)
    }.unsafe_perform;

    // Performs an action with a borrowed pointer to the internal data.
    _borrow : (MPZHandle -> a) -> MPZ -> a;
    _borrow = |act, num| num.@_0.borrow(|handle| act(handle));

    // Acts on the internal data of the MPZ, which may mutate the MPZ value, and returns the mutated MPZ paired with the result of the action.
    _mutate : (MPZHandle -> IO a) -> MPZ -> (MPZ, a);
    _mutate = |act, num| (
        let dtor = num.@_0;
        let (dtor, res) = dtor.mutate_unique(MPZHandle::_copy_constructor, act);
        (MPZ { _0 : dtor }, res)
    );

    // Apply a unary operation of GMP (taking (out, in) as arguments) to a `MPZ` value.
    _unary_op : ((MPZHandle, MPZHandle) -> IO ()) -> MPZ -> MPZ;
    _unary_op = |act, num| (
        let (is_unique, num) = num.unsafe_is_unique;
        if is_unique {
            num._mutate(|num_ptr| act((num_ptr, num_ptr))).@0
        } else {
            num._borrow(|num_ptr|
                MPZ::zero._mutate(|out_ptr| act((out_ptr, num_ptr))).@0
            )
        }
    );

    // Apply a unary operation of GMP (taking (out1, out2, in) as arguments) to a `MPZ` value.
    _unary_op2 : ((MPZHandle, MPZHandle, MPZHandle) -> IO ()) -> MPZ -> (MPZ, MPZ);
    _unary_op2 = |act, num| (
        let (is_unique, num) = num.unsafe_is_unique;
        if is_unique {
            num._mutate(|num_ptr| 
                MPZ::zero._mutate(|out2_ptr|
                    act((num_ptr, out2_ptr, num_ptr))
                ).@0.pure
            )
        };
        num._borrow(|num_ptr|
            MPZ::zero._mutate(|out1_ptr|
                MPZ::zero._mutate(|out2_ptr|
                    act((out1_ptr, out2_ptr, num_ptr))
                ).@0.pure
            )
        )
    );

    // Apply a binary operation of GMP (taking (out, lhs, rhs) as arguments) to two `MPZ` values.
    _binary_op : ((MPZHandle, MPZHandle, MPZHandle) -> IO ()) -> MPZ -> MPZ -> MPZ;
    _binary_op = |act, lhs, rhs| (
        let (is_unique, lhs) = lhs.unsafe_is_unique;
        if is_unique { 
            rhs._borrow(|rhs_ptr|
                lhs._mutate(|lhs_ptr| act((lhs_ptr, lhs_ptr, rhs_ptr))).@0
            )
        };
        let (is_uqniue, rhs) = rhs.unsafe_is_unique;
        if is_unique { 
            lhs._borrow(|lhs_ptr|
                rhs._mutate(|rhs_ptr| act((rhs_ptr, lhs_ptr, rhs_ptr))).@0
            )
        };
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                MPZ::zero._mutate(|out_ptr| act((out_ptr, lhs_ptr, rhs_ptr))).@0
            )
        )
    );

    // Apply a binary operation which returns two values of GMP (taking (out0, out1, lhs, rhs) as arguments) to two `MPZ` values.
    _binary_op2 : ((MPZHandle, MPZHandle, MPZHandle, MPZHandle) -> IO ()) -> MPZ -> MPZ -> (MPZ, MPZ);
    _binary_op2 = |act, lhs, rhs| (
        let (lhs_is_unique, lhs) = lhs.unsafe_is_unique;
        let (rhs_is_unique, rhs) = rhs.unsafe_is_unique;
        if lhs_is_unique && rhs_is_unique {
            lhs._mutate(|lhs_ptr| 
                rhs._mutate(|rhs_ptr|
                    act((lhs_ptr, rhs_ptr, lhs_ptr, rhs_ptr))
                ).@0.pure
            )
        };
        if lhs_is_unique && !rhs_is_unique {
            rhs._borrow(|rhs_ptr|
                lhs._mutate(|lhs_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        act((lhs_ptr, out2_ptr, lhs_ptr, rhs_ptr))
                    ).@0.pure
                )
            )
        };
        if !lhs_is_unique && rhs_is_unique {
            lhs._borrow(|lhs_ptr|
                rhs._mutate(|rhs_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        act((rhs_ptr, out2_ptr, lhs_ptr, rhs_ptr))
                    ).@0.pure
                )
            )
        };
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                MPZ::zero._mutate(|out1_ptr| 
                    MPZ::zero._mutate(|out2_ptr|
                        act((out1_ptr, out2_ptr, lhs_ptr, rhs_ptr))
                    ).@0.pure
                )
            )
        )
    );

    // Apply a tertiary operation of GMP (taking (out, op1, op2, op3) as arguments) to two `MPZ` values.
    _tertiary_op : ((MPZHandle, MPZHandle, MPZHandle, MPZHandle) -> IO ()) -> MPZ -> MPZ -> MPZ -> MPZ;
    _tertiary_op = |act, op1, op2, op3| (
        let (is_unique, op1) = op1.unsafe_is_unique;
        if is_unique {
            op2._borrow(|op2_ptr|
                op3._borrow(|op3_ptr|
                    op1._mutate(|op1_ptr| act((op1_ptr, op1_ptr, op2_ptr, op3_ptr))).@0
                )
            )
        };
        let (is_unique, op2) = op2.unsafe_is_unique;
        if is_unique {
            op1._borrow(|op1_ptr|
                op3._borrow(|op3_ptr|
                    op2._mutate(|op2_ptr| act((op2_ptr, op1_ptr, op2_ptr, op3_ptr))).@0
                )
            )
        };
        let (is_unique, op3) = op3.unsafe_is_unique;
        if is_unique {
            op1._borrow(|op1_ptr|
                op2._borrow(|op2_ptr|
                    op3._mutate(|op3_ptr| act((op3_ptr, op1_ptr, op2_ptr, op3_ptr))).@0
                )
            )
        };
        op1._borrow(|op1_ptr|
            op2._borrow(|op2_ptr|
                op3._borrow(|op3_ptr|
                    MPZ::zero._mutate(|out_ptr| act((out_ptr, op1_ptr, op2_ptr, op3_ptr))).@0
                )
            )
        )
    );
    
    // Create a `MPZ` value from an `I64`.
    // 
    // # Parameters
    // - `n`: The `I64` value to convert.
    mpz : I64 -> MPZ;
    mpz = MPZ::init_set_si;

    // The value `0`
    zero : MPZ;
    zero = MPZ::_init_by(|handle| FFI_CALL_IO[() __gmpz_init(Ptr), handle]).@0;

    // The value `1`
    one : MPZ;
    one = MPZ::init_set_si(1);

    // Sets the value of a MPZ to the given string in the given base.
    // 
    // If the string is not a valid representation of an integer in the given base, this function returns none.
    // See document of `mpz_set_str` in GMP for details.
    // 
    // # Parameters
    // - `str`: The string representation of the integer.
    // - `base`: The base of the string representation.
    // - `num`: The `MPZ` value to set.
    set_str : String -> I64 -> MPZ -> Option MPZ;
    set_str = |str, base, x| (
        str.borrow_c_str(|str_c_str| (
            let (x, res) = x._mutate(|ptr| 
                FFI_CALL_IO[CInt __gmpz_set_str(Ptr, Ptr, CInt), ptr, str_c_str, base.to_CInt]
            );
            if res == -1.to_CInt { Option::none() };
            Option::some $ x
        ))
    );

    // Creates a `MPZ` value represented by a string in the given base.
    // 
    // If the string is not a valid representation of an integer in the given base, this function returns none.
    // See document of `mpz_set_str` in GMP for details.
    // 
    // # Parameters
    // - `str`: The string representation of the integer.
    // - `base`: The base of the string representation.
    init_set_str : String -> I64 -> Option MPZ;
    init_set_str = |str, base| (
        str.borrow_c_str(|str_c_str| (
            let (num, res) = MPZ::_init_by(|ptr| 
                FFI_CALL_IO[CInt __gmpz_init_set_str(Ptr, Ptr, CInt), ptr, str_c_str, base.to_CInt]
            );
            if res == -1.to_CInt { Option::none() };
            Option::some $ num
        ))
    );

    // Sets the value of a MPZ to the given I64 value.
    // 
    // # Parameters
    // - `val`: The I64 value to set.
    // - `x`: The `MPZ` value to set.
    set_si : I64 -> MPZ -> MPZ;
    set_si = |val, x| (
        x._mutate(|ptr| FFI_CALL_IO[() __gmpz_set_si(Ptr, CLong), ptr, val]).@0
    );

    // Creates a `MPZ` value represented by an I64 value.
    // 
    // # Parameters
    // - `val`: The I64 value to represent.
    init_set_si : I64 -> MPZ;
    init_set_si = |val| MPZ::_init_by(|ptr| FFI_CALL_IO[() __gmpz_init_set_si(Ptr, CLong), ptr, val]).@0;
   
    // Sets the value of a MPZ to the given U64 value.
    // 
    // # Parameters
    // - `val`: The U64 value to set.
    // - `x`: The `MPZ` value to set.
    set_ui : U64 -> MPZ -> MPZ;
    set_ui = |val, x| (
        x._mutate(|ptr| FFI_CALL_IO[() __gmpz_set_ui(Ptr, CUnsignedLong), ptr, val]).@0
    );

    // Creates a `MPZ` value represented by an U64 value.
    // 
    // # Parameters
    // - `val`: The U64 value to represent.
    init_set_ui : U64 -> MPZ;
    init_set_ui = |val| MPZ::_init_by(|ptr| FFI_CALL_IO[() __gmpz_init_set_ui(Ptr, CUnsignedLong), ptr, val]).@0;

    // Sets the value of a MPZ to the integer part of a F64 value.
    set_d : F64 -> MPZ -> MPZ;
    set_d = |val, x| (
        x._mutate(|ptr| FFI_CALL_IO[() __gmpz_set_d(Ptr, CDouble), ptr, val]).@0
    );

    // Creates a `MPZ` value represented by a F64 value.
    // 
    // # Parameters
    // - `val`: The F64 value to represent.
    init_set_d : F64 -> MPZ;
    init_set_d = |val| MPZ::_init_by(|ptr| FFI_CALL_IO[() __gmpz_init_set_d(Ptr, CDouble), ptr, val]).@0;

    // Sets the value of a MPZ to the integer part of a MPQ value.
    // 
    // # Parameters
    // - `q`: The `MPQ` value to set.
    // - `x`: The `MPZ` value to set.
    set_q : MPQ -> MPZ -> MPZ;
    set_q = |q, x| (
        q._borrow(|q_ptr| (
            x._mutate(|x_ptr| (
                FFI_CALL_IO[() __gmpz_set_q(Ptr, Ptr), x_ptr, q_ptr]
            )).@0
        ))
    );

    // Converts a `MPZ` value to an I64 value.
    // 
    // If the value is too large to fit in an I64, this function returns none.
    get_si : MPZ -> Option I64;
    get_si = |num| (
        num._borrow(|num_ptr| (
            let fits = FFI_CALL[CInt __gmpz_fits_slong_p(Ptr), num_ptr];
            if fits == 0.to_CInt { Option::none() };
            let res = FFI_CALL[CLong __gmpz_get_si(Ptr), num_ptr];
            Option::some $ res.to_I64
        ))
    );

    // Converts a `MPZ` value to an U64 value.
    //
    // If the value is too large to fit in an U64, this function returns none.
    to_U64 : MPZ -> Option U64;
    to_U64 = |num| (
        num._borrow(|num_ptr| (
            let fits = FFI_CALL[CInt __gmpz_fits_ulong_p(Ptr), num_ptr];
            if fits == 0.to_CInt { Option::none() };
            let res = FFI_CALL[CUnsignedLong __gmpz_get_ui(Ptr), num_ptr];
            Option::some $ res
        ))
    );

    // Converts a `MPZ` value to an F64 value.
    //
    // For details, see the document of `mpz_get_d` in GMP.
    to_F64 : MPZ -> F64;
    to_F64 = |num| (
        num._borrow(|num_ptr| (
            FFI_CALL[CDouble __gmpz_get_d(Ptr), num_ptr].to_F64
        ))
    );

    // Converts a `MPZ` value to the pair (F64 value, exponent).
    // 
    // For details, see the document of `mpz_get_d_2exp` in GMP.
    to_F64_2exp : MPZ -> (F64, I64);
    to_F64_2exp = |num| (
        let exp = Box::make(0.to_CLong);
        let (exp, man) = num._borrow(|num_ptr| exp.mutate_boxed(|exp_ptr| 
            FFI_CALL_IO[CDouble __gmpz_get_d_2exp(Ptr, Ptr), exp_ptr, num_ptr]
        ));
        (man, exp.@value.to_I64)
    );

    // Converts a `MPZ` value to a string in the given base.
    // 
    // # Parameters
    // - `base`: The base of the string representation, which must be in the range [-36, -2] or [2, 62].
    // - `num`: The `MPZ` value to convert.
    get_string : I64 -> MPZ -> String;
    get_string = |base, num| (
        if base < -36 || base > 62 || (-2 < base && base < 2) {
            undefined("[MPZ::get_string] base must be in the range [-36, -2] or [2, 62]")
        };
        let base = base.to_CInt;
        num._borrow(|num_ptr| (
            let len_base = FFI_CALL[CSizeT __gmpz_sizeinbase(Ptr, CInt), num_ptr, base];
            let len = len_base.to_I64 + 2;
            let buf = Array::fill(len, 0_U8);
            let (buf, _) = buf.mutate_boxed(|buf_ptr| 
                FFI_CALL_IO[Ptr __gmpz_get_str(Ptr, CInt, Ptr), buf_ptr, base, num_ptr]
            );
            String::_unsafe_from_c_str(buf)
        ))
    );

    // Calculates the absolute value of a `MPZ` value.
    // 
    // # Parameters
    // - `num`: The `MPZ` value to calculate the absolute value of.
    abs : MPZ -> MPZ;
    abs = |num| num._unary_op(|(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpz_abs(Ptr, Ptr), out_ptr, in_ptr]);

    // Multiplication by a power of 2.
    mul_2exp : U64 -> MPZ -> MPZ;
    mul_2exp = |exp, num| (
        num._unary_op(|(out_ptr, num_ptr)| FFI_CALL_IO[() __gmpz_mul_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, num_ptr, exp.to_CUnsignedLong])
    );

    // Exact Divisions

    // Checks if `n` is divisible by `d`.
    //
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    divisible_p : MPZ -> MPZ -> Bool;
    divisible_p = |d, n| (
        d._borrow(|d_ptr| (
            n._borrow(|n_ptr| (
                FFI_CALL[CInt __gmpz_divisible_p(Ptr, Ptr), n_ptr, d_ptr] != 0.to_CInt
            ))
        ))
    );

    // Checks if `n` is divisible by `2^b`.
    //
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    divisible_2exp_p : U64 -> MPZ -> Bool;
    divisible_2exp_p = |bit, n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CInt __gmpz_divisible_2exp_p(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong] != 0.to_CInt
        ))
    );

    // Divides `n` by `d` and returns the quotient.
    // 
    // This function assumes that `n` is divisible by `d`.
    //
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    divexact : MPZ -> MPZ -> MPZ;
    divexact = |d, n| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_divexact(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            n, d
        )
    );

    // Modulo

    // Calculates the remainder of `n` divided by `d`.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    mod : MPZ -> MPZ -> MPZ;
    mod = |d, n| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_mod(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            n, d
        )
    );

    // Checks if two values `a`, `b` are congruent modulo `m`.
    //
    // # Parameters
    // - `m`: The modulus.
    // - `a`: The first value.
    // - `b`: The second value.
    congruent_p : MPZ -> MPZ -> MPZ -> Bool;
    congruent_p = |m, a, b| (
        a._borrow(|a_ptr| (
            b._borrow(|b_ptr| (
                m._borrow(|m_ptr| (
                    FFI_CALL[CInt __gmpz_congruent_p(Ptr, Ptr, Ptr), a_ptr, b_ptr, m_ptr] != 0.to_CInt
                ))
            ))
        ))
    );

    // Checks if two values `a`, `b` are congruent modulo `2^b`.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `a`: The first value.
    // - `b`: The second value.
    congruent_2exp_p : U64 -> MPZ -> MPZ -> Bool;
    congruent_2exp_p = |bit, a, b| (
        a._borrow(|a_ptr| (
            b._borrow(|b_ptr| (
                FFI_CALL[CInt __gmpz_congruent_2exp_p(Ptr, Ptr, CUnsignedLong), a_ptr, b_ptr, bit.to_CUnsignedLong] != 0.to_CInt
            ))
        ))
    );

    // Division and remainder

    // Divides `n` by `d` and returns the quotient and remainder.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    tdiv_qr : MPZ -> MPZ -> (MPZ, MPZ);
    tdiv_qr = |d, n| (
        MPZ::_binary_op2(
            |(q_ptr, r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_tdiv_qr(Ptr, Ptr, Ptr, Ptr), q_ptr, r_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `d` and returns the quotient.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    tdiv_q : MPZ -> MPZ -> MPZ;
    tdiv_q = |d, n| (
        MPZ::_binary_op(
            |(q_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_tdiv_q(Ptr, Ptr, Ptr), q_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `d` and returns the remainder.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    tdiv_r : MPZ -> MPZ -> MPZ;
    tdiv_r = |d, n| (
        MPZ::_binary_op(
            |(r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_tdiv_r(Ptr, Ptr, Ptr), r_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `2^b` and returns the quotient.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    tdiv_q_2exp : U64 -> MPZ -> MPZ;
    tdiv_q_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_tdiv_q_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        )
    );

    // Divides `n` by `2^b` and returns the remainder.
    // 
    // "t" means "truncated", i.e., the quotient is rounded towards zero.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    tdiv_r_2exp : U64 -> MPZ -> MPZ;
    tdiv_r_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_tdiv_r_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        )
    );

    // Divides `n` by `d` and returns the quotient and remainder.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    fdiv_qr : MPZ -> MPZ -> (MPZ, MPZ);
    fdiv_qr = |d, n| (
        MPZ::_binary_op2(
            |(q_ptr, r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_fdiv_qr(Ptr, Ptr, Ptr, Ptr), q_ptr, r_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `d` and returns the quotient.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    fdiv_q : MPZ -> MPZ -> MPZ;
    fdiv_q = |d, n| (
        MPZ::_binary_op(
            |(q_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_fdiv_q(Ptr, Ptr, Ptr), q_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `d` and returns the remainder.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    fdiv_r : MPZ -> MPZ -> MPZ;
    fdiv_r = |d, n| (
        MPZ::_binary_op(
            |(r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_fdiv_r(Ptr, Ptr, Ptr), r_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `2^b` and returns the quotient.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    fdiv_q_2exp : U64 -> MPZ -> MPZ;
    fdiv_q_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_fdiv_q_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        )
    );

    // Divides `n` by `2^b` and returns the remainder.
    // 
    // "f" means "floored", i.e., the quotient is rounded towards negative infinity.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    fdiv_r_2exp : U64 -> MPZ -> MPZ;
    fdiv_r_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_fdiv_r_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        )
    );

    // Divides `n` by `d` and returns the quotient and remainder.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    cdiv_qr : MPZ -> MPZ -> (MPZ, MPZ);
    cdiv_qr = |d, n| (
        MPZ::_binary_op2(
            |(q_ptr, r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_cdiv_qr(Ptr, Ptr, Ptr, Ptr), q_ptr, r_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `d` and returns the quotient.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    cdiv_q : MPZ -> MPZ -> MPZ;
    cdiv_q = |d, n| (
        MPZ::_binary_op(
            |(q_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_cdiv_q(Ptr, Ptr, Ptr), q_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `d` and returns the remainder.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `d`: The divisor.
    // - `n`: The dividend.
    cdiv_r : MPZ -> MPZ -> MPZ;
    cdiv_r = |d, n| (
        MPZ::_binary_op(
            |(r_ptr, n_ptr, d_ptr)| FFI_CALL_IO[() __gmpz_cdiv_r(Ptr, Ptr, Ptr), r_ptr, n_ptr, d_ptr],
            n, d
        )
    );

    // Divides `n` by `2^b` and returns the quotient.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    cdiv_q_2exp : U64 -> MPZ -> MPZ;
    cdiv_q_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_cdiv_q_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        )
    );

    // Divides `n` by `2^b` and returns the remainder.
    // 
    // "c" means "ceiling", i.e., the quotient is rounded towards positive infinity.
    // 
    // # Parameters
    // - `bit`: The exponent of 2.
    // - `n`: The dividend.
    cdiv_r_2exp : U64 -> MPZ -> MPZ;
    cdiv_r_2exp = |bit, n| (
        MPZ::_unary_op(
            |(out_ptr, n_ptr)| FFI_CALL_IO[() __gmpz_cdiv_r_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, n_ptr, bit.to_CUnsignedLong],
            n
        )
    );

    // Calculates `x + a * b`.
    // 
    // # Parameters
    // - `a`
    // - `b`
    // - `x`
    addmul : MPZ -> MPZ -> MPZ -> MPZ;
    addmul = |op1, op2, rop| (
        op1._borrow(|op1_ptr| (
            op2._borrow(|op2_ptr| (
                rop._mutate(|rop_ptr| (
                    FFI_CALL_IO[() __gmpz_addmul(Ptr, Ptr, Ptr), rop_ptr, op1_ptr, op2_ptr]
                )).@0
            ))
        ))
    );

    // Calculates `x - a * b`.
    // 
    // # Parameters
    // - `a`
    // - `b`
    // - `x`
    submul : MPZ -> MPZ -> MPZ -> MPZ;
    submul = |op1, op2, rop| (
        op1._borrow(|op1_ptr| (
            op2._borrow(|op2_ptr| (
                rop._mutate(|rop_ptr| (
                    FFI_CALL_IO[() __gmpz_submul(Ptr, Ptr, Ptr), rop_ptr, op1_ptr, op2_ptr]
                )).@0
            ))
        ))
    );

    // Power

    // Calculates `b^e mod m`.
    // 
    // # Parameters
    // - `e`: The exponent.
    // - `m`: The modulus.
    // - `b`: The base.
    powm : MPZ -> MPZ -> MPZ -> MPZ;
    powm = |exp, mod, base| (
        MPZ::_tertiary_op(
            |(out_ptr, base_ptr, exp_ptr, mod_ptr)| FFI_CALL_IO[() __gmpz_powm(Ptr, Ptr, Ptr, Ptr), out_ptr, base_ptr, exp_ptr, mod_ptr],
            base, exp, mod
        )
    );

    // Calculates `b^e mod m`.
    // 
    // This is a secure version of `powm`. For details, see the document of `mpz_powm_sec` in GMP.
    // 
    // # Parameters
    // - `e`: The exponent.
    // - `m`: The modulus.
    // - `b`: The base.
    powm_sec : MPZ -> MPZ -> MPZ -> MPZ;
    powm_sec = |exp, mod, base| (
        MPZ::_tertiary_op(
            |(out_ptr, base_ptr, exp_ptr, mod_ptr)| FFI_CALL_IO[() __gmpz_powm(Ptr, Ptr, Ptr, Ptr), out_ptr, base_ptr, exp_ptr, mod_ptr],
            base, exp, mod
        )
    );    

    // Calculates `b^e`.
    // 
    // # Parameters
    // - `e`: The exponent.
    // - `b`: The base.
    pow_ui : U64 -> MPZ -> MPZ;
    pow_ui = |exp, base| (
        MPZ::_unary_op(
            |(out_ptr, base_ptr)| FFI_CALL_IO[() __gmpz_pow_ui(Ptr, Ptr, CUnsignedLong), out_ptr, base_ptr, exp.to_CUnsignedLong],
            base
        )
    );

    // Roots

    // Calculates the integer part of the n-th root of `x`.
    // 
    // # Parameters
    // - `n`: The root to calculate.
    // - `x`: The value to calculate the root of.
    root : U64 -> MPZ -> MPZ;
    root = |n, x| (
        MPZ::_unary_op(
            |(out_ptr, op_ptr)| FFI_CALL_IO[() __gmpz_root(Ptr, Ptr, CUnsignedLong), out_ptr, op_ptr, n.to_CUnsignedLong],
            x
        )
    );

    // Calculates the n-th root of `x` and the remainder.
    // 
    // # Returns
    // A pair (root, remainder) such that `x = root^n + remainder`.
    // 
    // # Parameters
    // - `n`: The root to calculate.
    // - `x`: The value to calculate the root of.
    root_rem : U64 -> MPZ -> (MPZ, MPZ);
    root_rem = |n, x| (
        MPZ::_unary_op2(
            |(out_ptr, rem_ptr, op_ptr)| FFI_CALL_IO[() __gmpz_rootrem(Ptr, Ptr, Ptr, CUnsignedLong), out_ptr, rem_ptr, op_ptr, n.to_CUnsignedLong],
            x
        )
    );

    // Calculates the integer part of the root of `x` and the remainder.
    //
    // # Parameters
    // - `x`: The value to calculate the root of.
    sqrt : MPZ -> MPZ;
    sqrt = |x| (
        MPZ::_unary_op(
            |(out_ptr, op_ptr)| FFI_CALL_IO[() __gmpz_sqrt(Ptr, Ptr), out_ptr, op_ptr],
            x
        )
    );

    // Calculates the square root of `x` and the remainder.
    // 
    // # Returns
    // A pair (root, remainder) such that `x = root^2 + remainder
    //
    // # Parameters
    // - `x`: The value to calculate the square root of.
    sqrt_rem : MPZ -> (MPZ, MPZ);
    sqrt_rem = |x| (
        MPZ::_unary_op2(
            |(out_ptr, rem_ptr, op_ptr)| FFI_CALL_IO[() __gmpz_sqrtrem(Ptr, Ptr, Ptr), out_ptr, rem_ptr, op_ptr],
            x
        )
    );

    // Checks if `x` is a perfect power, i.e., `x = a^b` for some integers `a` and `b >= 2`.
    perfect_power_p : MPZ -> Bool;
    perfect_power_p = |x| (
        x._borrow(|x_ptr| (
            FFI_CALL[CInt __gmpz_perfect_power_p(Ptr), x_ptr] != 0.to_CInt
        ))
    );

    // Checks if `x` is a perfect square, i.e., `x = a^2` for some integer `a`.
    perfect_square_p : MPZ -> Bool;
    perfect_square_p = |x| (
        x._borrow(|x_ptr| (
            FFI_CALL[CInt __gmpz_perfect_square_p(Ptr), x_ptr] != 0.to_CInt
        ))
    );

    // Number theoretic functions

    // Comparisons

    // Compares two `MPZ` values.
    // 
    // # Returns
    // - a negative if `lhs < rhs`
    // - zero if `lhs == rhs`
    // - a positive if `lhs > rhs`
    //
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    cmp : MPZ -> MPZ -> I64;
    cmp = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[CInt __gmpz_cmp(Ptr, Ptr), lhs_ptr, rhs_ptr].to_I64
            ))
        ))
    );

    // Compares a `MPZ` value and an `F64` value.
    // 
    // # Returns
    // - a negative if `lhs < rhs`
    // - zero if `lhs == rhs`
    // - a positive if `lhs > rhs`
    //
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    cmp_d : MPZ -> F64 -> I64;
    cmp_d = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            FFI_CALL[CInt __gmpz_cmp_d(Ptr, CDouble), lhs_ptr, rhs].to_I64
        ))
    );

    // Compares absolute values of two `MPZ` values.
    // 
    // # Returns
    // - a negative if `|lhs| < |rhs|`
    // - zero if `|lhs| == |rhs|`
    // - a positive if `|lhs| > |rhs|`
    //
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    cmpabs : MPZ -> MPZ -> I64;
    cmpabs = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[CInt __gmpz_cmpabs(Ptr, Ptr), lhs_ptr, rhs_ptr].to_I64
            ))
        ))
    );

    // Compares absolute values of a `MPZ` value and an `F64` value.
    // 
    // # Returns
    // - a negative if `|lhs| < |rhs|`
    // - zero if `|lhs| == |rhs|`
    // - a positive if `|lhs| > |rhs|`
    //
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    cmpabs_d : MPZ -> F64 -> I64;
    cmpabs_d = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            FFI_CALL[CInt __gmpz_cmpabs_d(Ptr, CDouble), lhs_ptr, rhs].to_I64
        ))
    );

    // Returns the sign of a `MPZ` value.
    // 
    // # Returns
    // - `-1` if `n < 0`
    // - `0` if `n == 0`
    // - `1` if `n > 0`
    sgn : MPZ -> I64;
    sgn = |n| (
        let r = cmp(n, MPZ::zero);
        if r < 0 { -1 };
        if r > 0 { 1 };
        0
    );

    // Bit operations

    // Logical and operation on two `MPZ` values.
    // 
    // # Parameters
    // - `lhs`: The left-hand side value.
    // - `rhs`: The right-hand side value.
    and : MPZ -> MPZ -> MPZ;
    and = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_and(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        )
    );

    // Logical or operation on two `MPZ` values.
    // 
    // # Parameters
    // - `lhs`: The left-hand-side value.
    // - `rhs`: The right-hand-side value.
    or : MPZ -> MPZ -> MPZ;
    or = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_ior(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        )
    );

    // Logical xor operation on two `MPZ` values.
    // 
    // # Parameters
    // - `lhs`: The left-hand-side value.
    // - `rhs`: The right-hand-side value.
    xor : MPZ -> MPZ -> MPZ;
    xor = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_xor(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        )
    );

    // Bitwise complement operation on a `MPZ` value.
    //
    // # Parameters
    // - `n`: The `MPZ` value to complement.
    com : MPZ -> MPZ;
    com = |n| (
        MPZ::_unary_op(
            |(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpz_com(Ptr, Ptr), out_ptr, in_ptr],
            n
        )
    );

    // Counts the number of bits set to `1` in a `MPZ` value.
    // 
    // For the behavior when `n` is negative, see the document of `mpz_popcount` in GMP.
    // 
    // # Parameters
    // - `n`: The `MPZ` value to count bits in.
    popcount : MPZ -> U64;
    popcount = |n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CUnsignedLong __gmpz_popcount(Ptr), n_ptr].to_U64
        ))
    );

    // Calculates the Hamming distance between two `MPZ` values.
    // 
    // For the behavior when `lhs` or `rhs` is negative, see the document of `mpz_hamdist` in GMP.
    // 
    // # Parameters
    // - `lhs`: The left-hand-side value.
    // - `rhs`: The right-hand-side value.
    hamdist : MPZ -> MPZ -> U64;
    hamdist = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[CUnsignedLong __gmpz_hamdist(Ptr, Ptr), lhs_ptr, rhs_ptr].to_U64
            ))
        ))
    );

    // Scans `0` bit in a `MPZ` value starting from the specified bit.
    // 
    // # Parameters
    // - `bit`: The bit to start scanning from.
    // - `n`: The `MPZ` value to scan.
    scan0 : U64 -> MPZ -> U64;
    scan0 = |bit, n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CUnsignedLong __gmpz_scan0(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong].to_U64
        ))
    );

    // Scans `1` bit in a `MPZ` value starting from the specified bit.
    // 
    // # Parameters
    // - `bit`: The bit to start scanning from.
    // - `n`: The `MPZ` value to scan.
    scan1 : U64 -> MPZ -> U64;
    scan1 = |bit, n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CUnsignedLong __gmpz_scan1(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong].to_U64
        ))
    );

    // Sets the specified bit in a `MPZ` value to `1`.
    // 
    // # Parameters
    // - `bit`: The bit to set.
    // - `n`: The `MPZ` value to modify.
    setbit : U64 -> MPZ -> MPZ;
    setbit = |bit, n| (
        n._mutate(|n_ptr| (
            FFI_CALL_IO[() __gmpz_setbit(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong]
        )).@0
    );

    // Sets the specified bit in a `MPZ` value to `0`.
    // 
    // # Parameters
    // - `bit`: The bit to clear.
    // - `n`: The `MPZ` value to modify.
    clrbit : U64 -> MPZ -> MPZ;
    clrbit = |bit, n| (
        n._mutate(|n_ptr| (
            FFI_CALL_IO[() __gmpz_clrbit(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong]
        )).@0
    );

    // Toggles the specified bit in a `MPZ` value.
    //
    // # Parameters
    // - `bit`: The bit to toggle.
    // - `n`: The `MPZ` value to modify.
    combit : U64 -> MPZ -> MPZ;
    combit = |bit, n| (
        n._mutate(|n_ptr| (
            FFI_CALL_IO[() __gmpz_combit(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong]
        )).@0
    );

    // Checks if the specified bit in a `MPZ` value is set to `1`.
    // 
    // # Parameters
    // - `bit`: The bit to check.
    // - `n`: The `MPZ` value to check.
    tstbit : U64 -> MPZ -> Bool;
    tstbit = |bit, n| (
        n._borrow(|n_ptr| (
            FFI_CALL[CInt __gmpz_tstbit(Ptr, CUnsignedLong), n_ptr, bit.to_CUnsignedLong] != 0.to_CInt
        ))
    );
}

impl MPZ : Add {
    add = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_add(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        )
    );
}

impl MPZ : Sub {
    sub = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_sub(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        )
    );
}

impl MPZ : Mul {
    mul = |lhs, rhs| (
        MPZ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpz_mul(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        )
    );
}

impl MPZ : Neg {
    neg = |num| (
        num._unary_op(|(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpz_neg(Ptr, Ptr), out_ptr, in_ptr])
    );
}

impl MPZ : Eq {
    eq = |lhs, rhs| MPZ::cmp(lhs, rhs) == 0;
}

impl MPZ : Rem {
    rem = |n, d| n.MPZ::tdiv_r(d);
}

impl MPZ : Div {
    div = |n, d| n.MPZ::tdiv_q(d);
}

impl MPZ : LessThan {
    less_than = |lhs, rhs| MPZ::cmp(lhs, rhs) < 0;
}

impl MPZ : LessThanOrEq {
    less_than_or_eq = |lhs, rhs| MPZ::cmp(lhs, rhs) <= 0;
}

impl MPZ : ToString {
    to_string = |num| num.get_string(10);
}

impl MPZ : FromString {
    from_string = |s| match init_set_str(s, 10) {
        none() => err $ "Failed to parse MPZ as a decimal string",
        some(value) => ok $ value
    };
}

impl MPZ : Hash {
    hash = to_string >> hash;
}