module GMP.Z;

import Hash;

// An equivalent type to `__mpz_struct`.
type MPZStruct = box struct {
    _mp_alloc : CInt,
    _mp_size : CInt,
    _mp_d : Ptr
};

namespace MPZStruct {
    _null : MPZStruct;
    _null = MPZStruct {
        _mp_alloc : 0.to_CInt,
        _mp_size : 0.to_CInt,
        _mp_d : nullptr
    };

    _constructor : Ptr -> IO ();
    _constructor = |ptr| IO::from_runner $ |ios| FFI_CALL_IO[() __gmpz_init(Ptr), ptr, ios];

    _destructor : MPZStruct -> IO MPZStruct;
    _destructor = |mpz_s| (
        let (mpz_s, _) = *mpz_s.unsafe_mutate_boxed_data_io(|ptr| IO::from_runner $ |ios| FFI_CALL_IO[() __gmpz_clear(Ptr), ptr, ios]);
        pure $ mpz_s
    );
}

// Integer type with arbitrary precision.
type MPZ = unbox struct { _0 : Destructor MPZStruct };

namespace MPZ {

    // Initialize a new MPZ.
    _init : MPZ;
    _init = (
        let (mpz_s, _) = MPZStruct::_null.unsafe_mutate_boxed_data(MPZStruct::_constructor);
        MPZ { _0 : Destructor::make(mpz_s, MPZStruct::_destructor) }
    );

    // Performs an action with a borrowed pointer to the internal data.
    _borrow : (Ptr -> a) -> MPZ -> a;
    _borrow = |act, num| num.@_0.borrow(|mpz_s| act(mpz_s._unsafe_get_boxed_data_ptr));

    // Swap the elements of a pair.
    _swap_pair : (a, b) -> (b, a);
    _swap_pair = |(a, b)| (b, a);

    _is_unique : MPZ -> (Bool, MPZ);
    _is_unique = |num| (
        let (is_unique, dtor) = num.@_0.unsafe_is_unique;
        (is_unique, MPZ { _0 : dtor })
    );

    _force_unique : MPZ -> MPZ;
    _force_unique = |num| (
        let (is_unique, num) = num._is_unique;
        if is_unique { num };
        let (mpz_s, dtor) = dtor.unsafe_make_unique;
        MPZ { _0 : Destructor::make(mpz_s, dtor) }
    );

    // Acts on the internal data of the MPZ, which may mutate the MPZ value, and returns the mutated MPZ paired with the result of the action.
    _mutate : (Ptr -> IO a) -> MPZ -> (MPZ, a);
    _mutate = |act, num| _swap_pair $ num.act__0(|dtor|
        let (is_unique, dtor) = dtor.unsafe_is_unique;
        dtor.act__value(|mpz_s| _swap_pair $ mpz_s.unsafe_mutate_boxed_data(act))
    );

    // The zero value.
    zero : MPZ;
    zero = MPZ::_init;

    // Sets the value of the MPZ to the given string in the given base.
    // 
    // If the string is not a valid representation of an integer in the given base, this function returns none.
    // 
    // See document of `mpz_set_str` in GMP for details.
    set_string : String -> I64 -> MPZ -> Option MPZ;
    set_string = |dec, base, num| (
        dec.borrow_c_str(|dec_c_str| (
            let (num, res) = num._mutate(|ptr| IO::from_runner $ |ios| 
                FFI_CALL_IO[CInt __gmpz_set_str(Ptr, Ptr, CInt), ptr, dec_c_str, base.to_CInt, ios]
            );
            if res == -1.to_CInt { Option::none() };
            Option::some $ num
        ))
    );

    // Returns the integer represented by the decimal string `str`.
    // 
    // If the string is not a valid representation of an integer in the given base, this function returns none.
    from_decimal : String -> Option MPZ;
    from_decimal = |dec| MPZ::zero.set_string(dec, 10);

    // Sets the value of the MPZ to the given I64.
    set_I64 : I64 -> MPZ -> MPZ;
    set_I64 = |val, num| (
        num._mutate(|ptr| IO::from_runner $ |ios| FFI_CALL_IO[() __gmpz_set_si(Ptr, CLong), ptr, val, ios]).@0
    );

    // Returns the integer represented by the I64 `val`.
    from_I64 : I64 -> MPZ;
    from_I64 = |val| MPZ::zero.set_I64(val);

    // set_U64 : U64 -> MPZ -> MPZ;
    // set_U64 = |val, num| (
    //     let num = num.make_zero_if_non_unique;
    //     let _ = num.borrow_ptr(|ptr| FFI_CALL[() fix_mpz_set_ui(Ptr, U64), ptr, val]);
    //     num
    // );

    // from_U64 : U64 -> MPZ;
    // from_U64 = |val| MPZ::zero.set_U64(val);

    // // Divisions

    // is_divisible_by : MPZ -> MPZ -> Bool;
    // is_divisible_by = |d, n| (
    //     d.borrow_ptr(|d_ptr| (
    //         n.borrow_ptr(|n_ptr| (
    //             FFI_CALL[I64 fix_mpz_divisible_p(Ptr, Ptr), n_ptr, d_ptr] != 0
    //         ))
    //     ))
    // );

    // divide_exactly_by : MPZ -> MPZ -> MPZ;
    // divide_exactly_by = |d, n| (
    //     let out = (
    //         let (d_is_unique, d) = d._is_unique_data;
    //         if d_is_unique { d };
    //         let (n_is_unique, n) = n._is_unique_data;
    //         if n_is_unique { n };
    //         MPZ::_make()
    //     );
    //     let _ = d.borrow_ptr(|d_ptr| (
    //         n.borrow_ptr(|n_ptr| (
    //             out.borrow_ptr(|out_ptr| (
    //                 FFI_CALL[() fix_mpz_divexact(Ptr, Ptr, Ptr), out_ptr, n_ptr, d_ptr]
    //             ))
    //         ))
    //     ));
    //     out
    // );

    // // Arithmetics

    // get_gcd : MPZ -> MPZ -> MPZ;
    // get_gcd = |lhs, rhs| (
    //     let out = (
    //         let (lhs_is_unique, lhs) = lhs._is_unique_data;
    //         if lhs_is_unique { lhs };
    //         let (rhs_is_unique, rhs) = rhs._is_unique_data;
    //         if rhs_is_unique { rhs };
    //         MPZ::_make()
    //     );
    //     lhs.borrow_ptr(|lhs_ptr| (
    //         rhs.borrow_ptr(|rhs_ptr| (
    //             out.borrow_ptr(|out_ptr| (
    //                 let _ = FFI_CALL[() fix_mpz_gcd(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr];
    //                 out
    //             ))
    //         ))
    //     ))
    // );

    // get_lcm : MPZ -> MPZ -> MPZ;
    // get_lcm = |lhs, rhs| (
    //     let out = (
    //         let (lhs_is_unique, lhs) = lhs._is_unique_data;
    //         if lhs_is_unique { lhs };
    //         let (rhs_is_unique, rhs) = rhs._is_unique_data;
    //         if rhs_is_unique { rhs };
    //         MPZ::_make()
    //     );
    //     lhs.borrow_ptr(|lhs_ptr| (
    //         rhs.borrow_ptr(|rhs_ptr| (
    //             out.borrow_ptr(|out_ptr| (
    //                 let _ = FFI_CALL[() fix_mpz_lcm(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr];
    //                 out
    //             ))
    //         ))
    //     ))
    // );

    // get_binomial : I64 -> MPZ -> MPZ;
    // get_binomial = |k, n| (
    //     if k < 0 { MPZ::zero };
    //     let out = (
    //         let (n_is_unique, n) = n._is_unique_data;
    //         if n_is_unique { n };
    //         MPZ::_make()
    //     );
    //     n.borrow_ptr(|n_ptr| (
    //         out.borrow_ptr(|out_ptr| (
    //             let _ = FFI_CALL[() fix_mpz_bin_ui(Ptr, Ptr, I64), out_ptr, n_ptr, k];
    //             out
    //         ))
    //     ))
    // );

    // get_power : I64 -> MPZ -> MPZ;
    // get_power = |exp, n| (
    //     let _ = assert(|_|"In get_pow, exp should be non-negative.", exp >= 0);
    //     let out = (
    //         let (n_is_unique, n) = n._is_unique_data;
    //         if n_is_unique { n };
    //         MPZ::_make()
    //     );
    //     n.borrow_ptr(|n_ptr| (
    //         out.borrow_ptr(|out_ptr| (
    //             let _ = FFI_CALL[() fix_mpz_pow_ui(Ptr, Ptr, I64), out_ptr, n_ptr, exp];
    //             out
    //         ))
    //     ))
    // );

    // // Bit operations
    
    // get_bit : I64 -> MPZ -> I32;
    // get_bit = |bit, num| (
    //     num.borrow_ptr(|num_ptr| (
    //         FFI_CALL[I32 fix_mpz_tstbit(Ptr, I64), num_ptr, bit]
    //     ))
    // );
}


// impl MPZ : Add {

//     add = |lhs, rhs| (
//         let out = (
//             let (lhs_is_unique, lhs) = lhs._is_unique_data;
//             if lhs_is_unique { lhs };
//             let (rhs_is_unique, rhs) = rhs._is_unique_data;
//             if rhs_is_unique { rhs };
//             MPZ::_make()
//         );
//         let _ = lhs.borrow_ptr(|lhs_ptr| (
//             rhs.borrow_ptr(|rhs_ptr| (
//                 out.borrow_ptr(|out_ptr| (
//                     FFI_CALL[() fix_mpz_add(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr]
//                 ))
//             ))
//         ));
//         out
//     );

// }

// impl MPZ : Sub {

//     sub = |lhs, rhs| (
//         let out = (
//             let (lhs_is_unique, lhs) = lhs._is_unique_data;
//             if lhs_is_unique { lhs };
//             let (rhs_is_unique, rhs) = rhs._is_unique_data;
//             if rhs_is_unique { rhs };
//             MPZ::_make()
//         );
//         let _ = lhs.borrow_ptr(|lhs_ptr| (
//             rhs.borrow_ptr(|rhs_ptr| (
//                 out.borrow_ptr(|out_ptr| (
//                     FFI_CALL[() fix_mpz_sub(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr]
//                 ))
//             ))
//         ));
//         out
//     );

// }

// impl MPZ : Mul {

//     mul = |lhs, rhs| (
//         let out = (
//             let (lhs_is_unique, lhs) = lhs._is_unique_data;
//             if lhs_is_unique { lhs };
//             let (rhs_is_unique, rhs) = rhs._is_unique_data;
//             if rhs_is_unique { rhs };
//             MPZ::_make()
//         );
//         let _ = lhs.borrow_ptr(|lhs_ptr| (
//             rhs.borrow_ptr(|rhs_ptr| (
//                 out.borrow_ptr(|out_ptr| (
//                     FFI_CALL[() fix_mpz_mul(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr]
//                 ))
//             ))
//         ));
//         out
//     );

// }

// impl MPZ : Eq {

//     eq = |lhs, rhs| (
//         lhs.borrow_ptr(|lhs_ptr| (
//             rhs.borrow_ptr(|rhs_ptr| (
//                 FFI_CALL[I64 fix_mpz_cmp(Ptr, Ptr), lhs_ptr, rhs_ptr] == 0
//             ))
//         ))
//     );

// }

// impl MPZ : LessThan {

//     less_than = |lhs, rhs| (
//         lhs.borrow_ptr(|lhs_ptr| (
//             rhs.borrow_ptr(|rhs_ptr| (
//                 FFI_CALL[I64 fix_mpz_cmp(Ptr, Ptr), lhs_ptr, rhs_ptr] < 0
//             ))
//         ))
//     );

// }

// impl MPZ : LessThanOrEq {

//     less_than_or_eq = |lhs, rhs| (
//         lhs.borrow_ptr(|lhs_ptr| (
//             rhs.borrow_ptr(|rhs_ptr| (
//                 FFI_CALL[I64 fix_mpz_cmp(Ptr, Ptr), lhs_ptr, rhs_ptr] <= 0
//             ))
//         ))
//     );

// }

impl MPZ : ToString {

    to_string = |num| (
        num._borrow(|num_ptr| (
            let len_base = FFI_CALL[CSizeT __gmpz_sizeinbase(Ptr, CInt), num_ptr, 10.to_CInt];
            let len = len_base.to_I64 + 2;
            let buf = Array::fill(len, 0_U8);
            let (buf, _) = buf.unsafe_mutate_boxed_data(|buf_ptr| IO::from_runner $ |ios|
                FFI_CALL_IO[Ptr __gmpz_get_str(Ptr, CInt, Ptr), buf_ptr, 10.to_CInt, num_ptr, ios]
            );
            String::_unsafe_from_c_str(buf)
        ))
    );

}

impl MPZ : Hash {

    hash = to_string >> hash;

}