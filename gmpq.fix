// Provides multiple-precision rational number type `MPQ` and related functions.
// 
// Repository: https://github.com/tttmmmyyyy/fixlang-gmp
module GMP.Q;

import GMP.Z;

// A pointer to struct `__mpq_struct`.
type MPQHandle = Ptr;

// Size of `__mpq_struct`.
c_SiZE_OF_MPQ : CInt;
c_SiZE_OF_MPQ = c_SiZE_OF_MPZ * 2.to_CInt;

namespace MPQHandle {
    // Construct MPQHandle by GMP's initialization function, e.g., `mpq_init`.
    _construct_by : (MPQHandle -> IO a) -> IO (MPQHandle, a);
    _construct_by = |ctor| (
        let handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SiZE_OF_MPQ];
        let res = *ctor(handle);
        pure $ (handle, res)
    );

    // Calls `mpq_init` and `mpq_set`
    _copy_constructor : MPQHandle -> IO MPQHandle;
    _copy_constructor = |handle| (
        let new_handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SiZE_OF_MPQ];
        FFI_CALL_IO[() __gmpq_init(Ptr), new_handle];;
        FFI_CALL_IO[() __gmpq_set(Ptr, Ptr), new_handle, handle];;
        pure $ new_handle
    );

    // Calls `mpq_clear`.
    _destructor : MPQHandle -> IO MPQHandle;
    _destructor = |handle| (
        FFI_CALL_IO[() __gmpq_clear(Ptr), handle];;
        FFI_CALL_IO[() free(Ptr), handle];;
        pure $ nullptr
    );
}

// Rational number type, represented by a pair of `MPZ` values (numerator and denominator).
type MPQ = unbox struct { _0 : Destructor MPQHandle };

namespace MPQ {
    // Initialize a new MPQ using specified GMPQ's initialization action.
    _init_by : (MPQHandle -> IO a) -> (MPQ, a);
    _init_by = |ctor| do {
        let (handle, res) = *MPQHandle::_construct_by(ctor);
        pure $ (MPQ { _0 : Destructor::make(handle, MPQHandle::_destructor) }, res)
    }.unsafe_perform;

    // Performs an action with a borrowed pointer to the internal data.
    _borrow : (MPQHandle -> a) -> MPQ -> a;
    _borrow = |act, num| num.@_0.borrow(|handle| act(handle));

    // Acts on the internal data of the MPQ, which may mutate the MPQ value, and returns the mutated MPQ paired with the result of the action.
    _mutate : (MPQHandle -> IO a) -> MPQ -> (MPQ, a);
    _mutate = |act, num| (
        let dtor = num.@_0;
        let (dtor, res) = dtor.mutate_unique(MPQHandle::_copy_constructor, act);
        (MPQ { _0 : dtor }, res)
    );

    // Apply a unary operation of GMP (taking (out, in) as arguments) to a `MPQ` value.
    _unary_op : ((MPQHandle, MPQHandle) -> IO a) -> MPQ -> (MPQ, a);
    _unary_op = |act, num| (
        let (is_unique, num) = num.unsafe_is_unique;
        if is_unique {
            num._mutate(|num_ptr| act((num_ptr, num_ptr)))
        };
        num._borrow(|num_ptr|
            (zero : MPQ)._mutate(|out_ptr| act((out_ptr, num_ptr)))
        )
    );

    // Apply a binary operation of GMP (taking (out, lhs, rhs) as arguments) to two `MPQ` values.
    _binary_op : ((MPQHandle, MPQHandle, MPQHandle) -> IO a) -> MPQ -> MPQ -> (MPQ, a);
    _binary_op = |act, lhs, rhs| (
        let (is_unique, lhs) = lhs.unsafe_is_unique;
        if is_unique { 
            rhs._borrow(|rhs_ptr|
                lhs._mutate(|lhs_ptr| act((lhs_ptr, lhs_ptr, rhs_ptr)))
            )
        };
        let (is_uqniue, rhs) = rhs.unsafe_is_unique;
        if is_unique { 
            lhs._borrow(|lhs_ptr|
                rhs._mutate(|rhs_ptr| act((rhs_ptr, lhs_ptr, rhs_ptr)))
            )
        };
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                (zero : MPQ)._mutate(|out_ptr| act((out_ptr, lhs_ptr, rhs_ptr)))
            )
        )
    );

    // Creates a new `MPQ` value from I64 numerator and denominator.
    // 
    // # Parameters
    // - `num`: The numerator as an `I64` value.
    // - `den`: The denominator as an `I64` value.
    mpq : I64 -> I64 -> MPQ;
    mpq = |num, den| (
        if den > 0 { 
            init_set_si(num, den.to_U64)
        };
        let negate = |x: I64| x.to_U64.bit_not + 1_U64;
        if num > 0 {
            init_set_si(-num, negate(den))
        };
        init_set_ui(negate(num), negate(den))
    );

    // Creates a new `MPQ` value from I64 numerator and denominator.
    // 
    // # Parameters
    // - `num`: The numerator as an `I64` value.
    // - `den`: The denominator as an `U64` value.
    init_set_si : I64 -> U64 -> MPQ;
    init_set_si = |num, den| (
        MPQ::_init_by(|handle|
            FFI_CALL_IO[() __gmpq_init(Ptr), handle];;
            FFI_CALL_IO[() __gmpq_set_si(Ptr, I64, U64), handle, num, den];;
            FFI_CALL_IO[() __gmpq_canonicalize(Ptr), handle];;
            pure()
        ).@0
    );

    // Sets the `MPQ` value to a rational number represented by an `I64` numerator and an `U64` denominator.
    // 
    // # Parameters
    // - `num`: The numerator as an `I64` value.
    // - `den`: The denominator as an `U64` value.
    // - `q`: The `MPQ` value to be set.
    set_si : I64 -> U64 -> MPQ -> MPQ;
    set_si = |num, den, q| (
        q._mutate(|q_ptr| (
            FFI_CALL_IO[() __gmpq_set_si(Ptr, I64, U64), q_ptr, num, den];;
            FFI_CALL_IO[() __gmpq_canonicalize(Ptr), q_ptr];;
            pure()
        )).@0
    );

    // Creates a new `MPQ` value from an `U64` value.
    //
    // # Parameters
    // - `num`: The numerator as an `U64` value.
    // - `den`: The denominator as an `U64` value.
    init_set_ui : U64 -> U64 -> MPQ;
    init_set_ui = |num, den| (
        MPQ::_init_by(|handle|
            FFI_CALL_IO[() __gmpq_init(Ptr), handle];;
            FFI_CALL_IO[() __gmpq_set_ui(Ptr, U64, U64), handle, num, den];;
            FFI_CALL_IO[() __gmpq_canonicalize(Ptr), handle];;
            pure()
        ).@0
    );

    // Sets the `MPQ` value to a rational number represented by an `U64` numerator and an `U64` denominator.
    // 
    // # Parameters
    // - `num`: The numerator as an `U64` value.
    // - `den`: The denominator as an `U64` value.
    // - `q`: The `MPQ` value to be set.
    set_ui : U64 -> U64 -> MPQ -> MPQ;
    set_ui = |num, den, q| (
        q._mutate(|q_ptr| (
            FFI_CALL_IO[() __gmpq_set_ui(Ptr, U64, U64), q_ptr, num, den];;
            FFI_CALL_IO[() __gmpq_canonicalize(Ptr), q_ptr];;
            pure()
        )).@0
    );

    // Creates a `MPQ` value by an MPZ value.
    // 
    // # Parameters
    // - `val`: The `MPZ` value to be converted to `MPQ
    init_set_z : MPZ -> MPQ;
    init_set_z = |val| val._borrow(|val_ptr|
        MPQ::_init_by(|handle|
            FFI_CALL_IO[() __gmpq_init(Ptr), handle];;
            FFI_CALL_IO[() __gmpq_set_z(Ptr, Ptr), handle, val_ptr]
        ).@0
    );

    // Sets the `MPQ` value to an `MPZ` value.
    // 
    // # Parameters
    // - `z`: The `MPZ` value to be set.
    // - `q`: The `MPQ` value to be set.
    set_z : MPZ -> MPQ -> MPQ;
    set_z = |z, q| (
        z._borrow(|z_ptr|
            q._mutate(|q_ptr| (
                FFI_CALL_IO[() __gmpq_set_z(Ptr, Ptr), q_ptr, z_ptr];;
                FFI_CALL_IO[() __gmpq_canonicalize(Ptr), q_ptr];;
                pure()
            )).@0        
        )
    );

    // Creates a new `MPQ` value from a floating-point number.
    // 
    // # Parameters
    // - `f`: The floating-point number to be converted to `MPQ`.
    init_set_d : F64 -> MPQ;
    init_set_d = |f| (
        MPQ::_init_by(|handle|
            FFI_CALL_IO[() __gmpq_init(Ptr), handle];;
            FFI_CALL_IO[() __gmpq_set_d(Ptr, CDouble), handle, f.to_CDouble];;
            FFI_CALL_IO[() __gmpq_canonicalize(Ptr), handle];;
            pure()
        ).@0
    );

    // Sets the `MPQ` value to a floating-point number.
    //  
    // # Parameters
    // - `f`: The floating-point number to set.
    // - `q`: The `MPQ` value to be set.
    set_d : F64 -> MPQ -> MPQ;
    set_d = |f, q| (
        q._mutate(|q_ptr| (
            let f = f.to_CDouble;
            FFI_CALL_IO[() __gmpq_set_d(Ptr, CDouble), q_ptr, f];;
            pure()
        )).@0
    );

    // Converts a `MPZ` value to an F64 value.
    //
    // For details, see the document of `mpz_get_d` in GMP.
    // 
    // # Parameters
    // - `num`: The `MPQ` value to be converted to F64.
    get_d : MPQ -> F64;
    get_d = |num| (
        num._borrow(|num_ptr| (
            FFI_CALL[CDouble __gmpq_get_d(Ptr), num_ptr].to_F64
        ))
    );

    // Creates new `MPQ` value from a string representation.
    // 
    // # Parameters
    // - `str`: The string representation of the rational number.
    // - `base`: The base of the string representation.
    init_set_str : String -> I64 -> Option MPQ;
    init_set_str = |str, base| (
        str.borrow_c_str(|c_str_ptr|
            let (num, res) = MPQ::_init_by(|handle|
                FFI_CALL_IO[() __gmpq_init(Ptr), handle];;
                let res = *FFI_CALL_IO[CInt __gmpq_set_str(Ptr, Ptr, CInt), handle, c_str_ptr, base.to_CInt];
                FFI_CALL_IO[() __gmpq_canonicalize(Ptr), handle];;
                res.pure
            );
            if res == -1.to_CInt { Option::none() };
            Option::some $ num
        )
    );

    // Sets the `MPQ` value from a string representation.
    // 
    // # Parameters
    // - `str`: The string representation of the rational number.
    // - `base`: The base of the string representation.
    // - `q`: The `MPQ` value to be set.
    set_str : String -> I64 -> MPQ -> Option MPQ;
    set_str = |str, base, q| (
        str.borrow_c_str(|c_str_ptr|
            let (num, res) = q._mutate(|q_ptr| 
                let res = *FFI_CALL_IO[CInt __gmpq_set_str(Ptr, Ptr, CInt), q_ptr, c_str_ptr, base.to_CInt];
                FFI_CALL_IO[() __gmpq_canonicalize(Ptr), q_ptr];;
                res.pure
            );
            if res == -1.to_CInt { Option::none() };
            Option::some $ num
        )
    );
    
    // Gets the numerator of the `MPQ` value.
    // 
    // # Parameters
    // - `num`: The `MPQ` value from which to get the numerator.
    get_num : MPQ -> MPZ;
    get_num = |num| (
        num._borrow(|num_ptr| (
            let num_z = (zero : MPZ)._mutate(|ptr| FFI_CALL_IO[() __gmpq_get_num(Ptr, Ptr), ptr, num_ptr]).@0;
            num_z
        ))
    );

    // Gets the denominator of the `MPQ` value.
    // 
    // # Parameters
    // - `num`: The `MPQ` value from which to get the denominator.
    get_den : MPQ -> MPZ;
    get_den = |num| (
        num._borrow(|num_ptr| (
            let den_z = (zero : MPZ)._mutate(|ptr| FFI_CALL_IO[() __gmpq_get_den(Ptr, Ptr), ptr, num_ptr]).@0;
            den_z
        ))
    );

    // Get the string representation of a `MPQ` value in the given base.
    get_str : I64 -> MPQ -> String;
    get_str = |base, num| (
        if !(2 <= base && base <= 36) {
            undefined("[MPQ::get_str] `base` must be in the range [2, 36]")
        };
        let base = base.to_CInt;        
        num._borrow(|x_ptr| (
            let str_ptr = FFI_CALL[Ptr __gmpq_get_str(Ptr, CInt, Ptr), nullptr, base.to_CInt, x_ptr];
            let str = String::_unsafe_from_c_str_ptr(str_ptr);
            FFI_CALL_IO[() free(Ptr), str_ptr];;
            str.pure
        ).unsafe_perform)
    );

    // Multiplies the `MPQ` value by `2^exp`.
    // 
    // # Parameters
    // - `exp`: The exponent of 2.
    // - `num`: The `MPQ` value to be multiplied.
    mul_2exp : U64 -> MPQ -> MPQ;
    mul_2exp = |exp, num| (
        num._unary_op(|(out_ptr, in_ptr)| (
            FFI_CALL_IO[() __gmpq_mul_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, in_ptr, exp.to_CUnsignedLong]
        )).@0
    );

    // Divides the `MPQ` value by `2^exp`.
    //
    // # Parameters
    // - `exp`: The exponent of 2.
    // - `num`: The `MPQ` value to be divided.
    div_2exp : U64 -> MPQ -> MPQ;
    div_2exp = |exp, num| (
        num._unary_op(|(out_ptr, in_ptr)| (
            FFI_CALL_IO[() __gmpq_div_2exp(Ptr, Ptr, CUnsignedLong), out_ptr, in_ptr, exp.to_CUnsignedLong]
        )).@0
    );

    // Returns the absolute value of the `MPQ` value.
    // 
    // # Parameters
    // - `num`: The `MPQ` value to be converted to its absolute value
    abs : MPQ -> MPQ;
    abs = |num| (
        num._unary_op(|(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpq_abs(Ptr, Ptr), out_ptr, in_ptr]).@0
    );

    // Returns the multiplicative inverse of the `MPQ` value.
    // 
    // # Parameters
    // - `num`: The `MPQ` value to be inverted.
    inv : MPQ -> MPQ;
    inv = |num| (
        num._unary_op(|(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpq_inv(Ptr, Ptr), out_ptr, in_ptr]).@0
    );

    // Compares two `MPQ` values.
    // 
    // # Returns
    // - a negative if `lhs` is less than `rhs`,
    // - zero if they are equal,
    // - a positive if `lhs` is greater than `rhs`.
    // 
    // # Parameters
    // - `lhs`: The left-hand side `MPQ` value.
    // - `rhs`: The right-hand side `MPQ` value.
    cmp : MPQ -> MPQ -> I64;
    cmp = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[CInt __gmpq_cmp(Ptr, Ptr), lhs_ptr, rhs_ptr].to_I64
            ))
        ))
    );

    // Compares an `MPQ` value with an `MPZ` value.
    // 
    // # Returns
    // - a negative if `lhs` is less than `rhs`,
    // - zero if they are equal,
    // - a positive if `lhs` is greater than `rhs`.
    //
    // # Parameters
    // - `lhs`: The left-hand side `MPQ` value.
    // - `rhs`: The right-hand side `MPZ` value.
    cmp_z : MPQ -> MPZ -> I64;
    cmp_z = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[CInt __gmpq_cmp_z(Ptr, Ptr), lhs_ptr, rhs_ptr].to_I64
            ))
        ))
    );

    // Checks if two `MPQ` values are equal.
    // 
    // # Parameters
    // - `lhs`: The left-hand side `MPQ` value.
    // - `rhs`: The right-hand side `MPQ` value.
    equal : MPQ -> MPQ -> Bool;
    equal = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[I64 __gmpq_equal(Ptr, Ptr), lhs_ptr, rhs_ptr] == 1
            ))
        ))
    );

    // Returns the sign of a `MPQ` value.
    // 
    // # Returns
    // - `-1` if `n < 0`
    // - `0` if `n == 0`
    // - `1` if `n > 0`
    sgn : MPQ -> I64;
    sgn = |num| (
        let r = MPQ::cmp(num, zero);
        if r < 0 { -1 };
        if r > 0 { 1 };
        0
    );

}

impl MPQ : Add {
    add = |lhs, rhs| (
        MPQ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpq_add(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPQ : Sub {
    sub = |lhs, rhs| (
        MPQ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpq_sub(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPQ : Mul {
    mul = |lhs, rhs| (
        MPQ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpq_mul(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPQ : Div {
    div = |lhs, rhs| (
        MPQ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpq_div(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPQ : Neg {
    neg = |num| (
        num._unary_op(|(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpq_neg(Ptr, Ptr), out_ptr, in_ptr]).@0
    );
}

impl MPQ : Eq {
    eq = equal;
}

impl MPQ : FromString {
    from_string = |s| match MPQ::init_set_str(s, 10) {
        none() => err $ "Failed to parse MPQ as a decimal string",
        some(value) => ok $ value
    };
}

impl MPQ : ToString {
    to_string = get_str(10);
}

impl MPQ : Zero {
    zero = MPQ::_init_by(|handle| FFI_CALL_IO[() __gmpq_init(Ptr), handle]).@0;
}

