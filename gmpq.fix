module GMP.Q;

import GMP.Z;

// A pointer to struct `__mpz_struct`.
type MPQHandle = Ptr;

// Size of `__mpq_struct`.
c_SiZE_OF_MPQ : CInt;
c_SiZE_OF_MPQ = c_SiZE_OF_MPZ * 2.to_CInt;

namespace MPQHandle {
    // Construct MPQHandle by GMP's initialization function, e.g., `mpq_init`.
    _construct_by : (MPQHandle -> IO a) -> IO (MPQHandle, a);
    _construct_by = |ctor| (
        let handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SiZE_OF_MPQ];
        let res = *ctor(handle);
        pure $ (handle, res)
    );

    // Calls `mpq_init` and `mpq_set`
    _copy_constructor : MPQHandle -> IO MPQHandle;
    _copy_constructor = |handle| (
        let new_handle = *FFI_CALL_IO[Ptr malloc(CInt), c_SiZE_OF_MPQ];
        FFI_CALL_IO[() __gmpq_init(Ptr), new_handle];;
        FFI_CALL_IO[() __gmpq_set(Ptr, Ptr), new_handle, handle];;
        pure $ new_handle
    );

    // Calls `mpq_clear`.
    _destructor : MPQHandle -> IO MPQHandle;
    _destructor = |handle| (
        FFI_CALL_IO[() __gmpq_clear(Ptr), handle];;
        FFI_CALL_IO[() free(Ptr), handle];;
        pure $ nullptr
    );
}

// Rational number type, represented by a pair of `MPZ` values (numerator and denominator).
type MPQ = unbox struct { _0 : Destructor MPQHandle };

namespace MPQ {
    // Initialize a new MPQ using specified GMPQ's initialization action.
    _init_by : (MPQHandle -> IO a) -> (MPQ, a);
    _init_by = |ctor| do {
        let (handle, res) = *MPQHandle::_construct_by(ctor);
        pure $ (MPQ { _0 : Destructor::make(handle, MPQHandle::_destructor) }, res)
    }.unsafe_perform;

    // Performs an action with a borrowed pointer to the internal data.
    _borrow : (MPQHandle -> a) -> MPQ -> a;
    _borrow = |act, num| num.@_0.borrow(|handle| act(handle));

    // Acts on the internal data of the MPQ, which may mutate the MPQ value, and returns the mutated MPQ paired with the result of the action.
    _mutate : (MPQHandle -> IO a) -> MPQ -> (MPQ, a);
    _mutate = |act, num| (
        let dtor = num.@_0;
        let (dtor, res) = dtor.mutate_unique(MPQHandle::_copy_constructor, act);
        (MPQ { _0 : dtor }, res)
    );

    // Apply a unary operation of GMP (taking (out, in) as arguments) to a `MPQ` value.
    _unary_op : ((MPQHandle, MPQHandle) -> IO a) -> MPQ -> (MPQ, a);
    _unary_op = |act, num| (
        let (is_unique, num) = num.unsafe_is_unique;
        if is_unique {
            num._mutate(|num_ptr| act((num_ptr, num_ptr)))
        };
        num._borrow(|num_ptr|
            MPQ::zero._mutate(|out_ptr| act((out_ptr, num_ptr)))
        )
    );

    // Apply a binary operation of GMP (taking (out, lhs, rhs) as arguments) to two `MPQ` values.
    _binary_op : ((MPQHandle, MPQHandle, MPQHandle) -> IO a) -> MPQ -> MPQ -> (MPQ, a);
    _binary_op = |act, lhs, rhs| (
        let (is_unique, lhs) = lhs.unsafe_is_unique;
        if is_unique { 
            rhs._borrow(|rhs_ptr|
                lhs._mutate(|lhs_ptr| act((lhs_ptr, lhs_ptr, rhs_ptr)))
            )
        };
        let (is_uqniue, rhs) = rhs.unsafe_is_unique;
        if is_unique { 
            lhs._borrow(|lhs_ptr|
                rhs._mutate(|rhs_ptr| act((rhs_ptr, lhs_ptr, rhs_ptr)))
            )
        };
        lhs._borrow(|lhs_ptr|
            rhs._borrow(|rhs_ptr|
                MPQ::zero._mutate(|out_ptr| act((out_ptr, lhs_ptr, rhs_ptr)))
            )
        )
    );
    
    // The zero value.
    zero : MPQ;
    zero = MPQ::_init_by(|handle| FFI_CALL_IO[() __gmpq_init(Ptr), handle]).@0;

    // The one value.
    one : MPQ;
    one = MPQ::init_set_ui(1_U64, 1_U64);

    // Creates a new `MPQ` value from I64 numerator and denominator.
    // 
    // # Parameters
    // - `num`: The numerator as an `I64` value.
    // - `den`: The denominator as an `I64` value.
    mpq : I64 -> I64 -> MPQ;
    mpq = |num, den| (
        if den > 0 { 
            init_set_si(num, den.to_U64)
        };
        let negate = |x: I64| x.to_U64.bit_not + 1_U64;
        if num > 0 {
            init_set_si(-num, negate(den))
        };
        init_set_ui(negate(num), negate(den))
    );

    // Creates a new `MPQ` value from I64 numerator and denominator.
    // 
    // # Parameters
    // - `num`: The numerator as an `I64` value.
    // - `den`: The denominator as an `U64` value.
    init_set_si : I64 -> U64 -> MPQ;
    init_set_si = |num, den| (
        MPQ::_init_by(|handle|
            FFI_CALL_IO[() __gmpq_init(Ptr), handle];;
            FFI_CALL_IO[() __gmpq_set_si(Ptr, I64, U64), handle, num, den];;
            FFI_CALL_IO[() __gmpq_canonicalize(Ptr), handle];;
            pure()
        ).@0
    );

    // Creates a new `MPQ` value from an `U64` value.
    //
    // # Parameters
    // - `num`: The numerator as an `U64` value.
    // - `den`: The denominator as an `U64` value.
    init_set_ui : U64 -> U64 -> MPQ;
    init_set_ui = |num, den| (
        MPQ::_init_by(|handle|
            FFI_CALL_IO[() __gmpq_init(Ptr), handle];;
            FFI_CALL_IO[() __gmpq_set_ui(Ptr, U64, U64), handle, num, den];;
            FFI_CALL_IO[() __gmpq_canonicalize(Ptr), handle];;
            pure()
        ).@0
    );

    // Creates a `MPQ` value by an MPZ value.
    // 
    // # Parameters
    // - `val`: The `MPZ` value to be converted to `MPQ
    init_set_z : MPZ -> MPQ;
    init_set_z = |val| val._borrow(|val_ptr|
        MPQ::_init_by(|handle|
            FFI_CALL_IO[() __gmpq_init(Ptr), handle];;
            FFI_CALL_IO[() __gmpq_set_z(Ptr, Ptr), handle, val_ptr]
        ).@0
    );

    // Sets the `MPQ` value to a floating-point number.
    //  
    // # Parameters
    // - `f`: The floating-point number to set.
    // - `q`: The `MPQ` value to be set.
    set_d : F64 -> MPQ -> MPQ;
    set_d = |f, q| (
        q._mutate(|q_ptr| (
            let f = f.to_CDouble;
            FFI_CALL_IO[() __gmpq_set_d(Ptr, CDouble), q_ptr, f];;
            pure()
        )).@0
    );

    // Converts a `MPZ` value to an F64 value.
    //
    // For details, see the document of `mpz_get_d` in GMP.
    // 
    // # Parameters
    // - `num`: The `MPQ` value to be converted to F64.
    get_d : MPQ -> F64;
    get_d = |num| (
        num._borrow(|num_ptr| (
            FFI_CALL[CDouble __gmpq_get_d(Ptr), num_ptr].to_F64
        ))
    );
    
    // Gets the numerator of the `MPQ` value.
    // 
    // # Parameters
    // - `num`: The `MPQ` value from which to get the numerator.
    get_num : MPQ -> MPZ;
    get_num = |num| (
        num._borrow(|num_ptr| (
            let num_z = MPZ::zero._mutate(|ptr| FFI_CALL_IO[() __gmpq_get_num(Ptr, Ptr), ptr, num_ptr]).@0;
            num_z
        ))
    );

    get_den : MPQ -> MPZ;
    get_den = |num| (
        num._borrow(|num_ptr| (
            let den_z = MPZ::zero._mutate(|ptr| FFI_CALL_IO[() __gmpq_get_den(Ptr, Ptr), ptr, num_ptr]).@0;
            den_z
        ))
    );

    // Get the string representation of a `MPQ` value in the given base.
    get_str : I64 -> MPQ -> String;
    get_str = |base, num| (
        if !(2 <= base && base <= 36) {
            undefined("[MPQ::get_str] `base` must be in the range [2, 36]")
        };
        let base = base.to_CInt;        
        num._borrow(|x_ptr| (
            let str_ptr = FFI_CALL[Ptr __gmpq_get_str(Ptr, CInt, Ptr), nullptr, base.to_CInt, x_ptr];
            let str = String::_unsafe_from_c_str_ptr(str_ptr);
            FFI_CALL_IO[() free(Ptr), str_ptr];;
            str.pure
        ).unsafe_perform)
    );
}

impl MPQ : Add {
    add = |lhs, rhs| (
        MPQ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpq_add(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPQ : Sub {
    sub = |lhs, rhs| (
        MPQ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpq_sub(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPQ : Mul {
    mul = |lhs, rhs| (
        MPQ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpq_mul(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPQ : Div {
    div = |lhs, rhs| (
        MPQ::_binary_op(
            |(out_ptr, lhs_ptr, rhs_ptr)| FFI_CALL_IO[() __gmpq_div(Ptr, Ptr, Ptr), out_ptr, lhs_ptr, rhs_ptr],
            lhs, rhs
        ).@0
    );
}

impl MPQ : Neg {
    neg = |num| (
        num._unary_op(|(out_ptr, in_ptr)| FFI_CALL_IO[() __gmpq_neg(Ptr, Ptr), out_ptr, in_ptr]).@0
    );
}

impl MPQ : Eq {
    eq = |lhs, rhs| (
        lhs._borrow(|lhs_ptr| (
            rhs._borrow(|rhs_ptr| (
                FFI_CALL[I64 __gmpq_cmp(Ptr, Ptr), lhs_ptr, rhs_ptr] == 0
            ))
        ))
    );
}

impl MPQ : ToString {
    to_string = get_str(10);
}
